
///
/// \file delegate.c
///
/// ReconOS delegate thread code for eCos. NOTE: This file is generated from
/// delegate.tmpl.
///
/// DO NOT EDIT THIS FILE - it will be regenerated, overwriting your changes
/// Edit the command definitions in $RECONOS/defs or delegate.tmpl instead.
///
/// \author     Enno Luebbers   <enno.luebbers@upb.de>
/// \date       30.10.2008
//
//---------------------------------------------------------------------------
// %%%RECONOS_COPYRIGHT_BEGIN%%%
// 
// This file is part of ReconOS (http://www.reconos.de).
// Copyright (c) 2006-2010 The ReconOS Project and contributors (see AUTHORS).
// All rights reserved.
// 
// ReconOS is free software: you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation, either version 3 of the License, or (at your option)
// any later version.
// 
// ReconOS is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
// details.
// 
// You should have received a copy of the GNU General Public License along
// with ReconOS.  If not, see <http://www.gnu.org/licenses/>.
// 
// %%%RECONOS_COPYRIGHT_END%%%
//---------------------------------------------------------------------------
//
// Major Changes:
//
// 30.10.2008   Enno Luebbers   delegate thread code seperated from reconos.c
// 07.11.2008   Enno Luebbers   wrote generator delegate.tmpl for delegate.c
// 29.01.2009   Enno Luebbers   added support for partial reconfiguration
//

#include <cyg/hal/hal_cache.h>
#include <cyg/infra/cyg_type.h>
#include <cyg/infra/diag.h>
#include <cyg/kernel/kapi.h>
#include <reconos/osif_comm.h>
#include <reconos/reconos.h>
#include <stdio.h>
#include <stdlib.h>
#ifdef UPBFUN_RECONOS_POSIX
#include <cyg/hal/hal_cache.h>
#include <cyg/posix/pthread.h>
#include <cyg/posix/semaphore.h>
#include <cyg/posix/types.h>
#include <fcntl.h>
#include <mqueue.h>
#endif

// CONSTANTS and MACROS ====================================================

#ifdef UPBDBG_RECONOS_DEBUG
#define DEBUG_PRINTF(format, args...) diag_printf(format , ##args)
#else
#define DEBUG_PRINTF(format, args...)
#endif

// ReconOS command encoding constants
// task2os commands
#define OSIF_CMD_COND_BROADCAST      0x05
#define OSIF_CMD_COND_SIGNAL      0x04
#define OSIF_CMD_COND_WAIT      0x84
#define OSIF_CMD_MBOX_GET      0x85
#define OSIF_CMD_MBOX_PUT      0x87
#define OSIF_CMD_MBOX_TRYGET      0x86
#define OSIF_CMD_MQ_RECEIVE      0x8C
#define OSIF_CMD_MQ_SEND      0x8A
#define OSIF_CMD_MUTEX_LOCK      0x82
#define OSIF_CMD_MUTEX_RELEASE      0x03
#define OSIF_CMD_MUTEX_TRYLOCK      0x83
#define OSIF_CMD_MUTEX_UNLOCK      0x02
#define OSIF_CMD_SEM_POST      0x00
#define OSIF_CMD_SEM_WAIT      0x81
#define OSIF_CMD_THREAD_DELAY      0x8D
#define OSIF_CMD_THREAD_EXIT      0xF0
#define OSIF_CMD_THREAD_YIELD      0xF1


// TYPE DEFINITIONS ========================================================


// FUNCTION PROTOTYPES =====================================================

// FIXME: should this be in a header file?
#ifdef CYGPKG_KERNEL_THREADS_DESTRUCTORS
void reconos_delegate_thread_destructor (cyg_addrword_t data);	// defined in reconos.c
#endif

extern reconos_slot_t reconos_slots[NUM_OSIFS];
#ifdef UPBFUN_RECONOS_PARTIAL
cyg_mutex_t reconos_hwsched_mutex;
cyg_cond_t reconos_hwsched_condvar;
cyg_sem_t reconos_hwsched_semaphore;
#endif


// FUNCTIONS ===============================================================


/**** DEPRECATED ****

///
/// Find a free slot
///
/// Returns an index into the possible_slots array, or -1
/// if none of the slots are free or ready.
///

int find_free_slot(uint8 *possible_slots, uint8 num_possible_slots) {
    int i, j;

    for (i = 0; i < num_possible_slots; i++) {
        // either free or not-executing slots are okay
        j = possible_slots[i];
        if (reconos_slots[j].state == FREE ||
            reconos_slots[j].state == READY) {
           return i;
        }
    }
    return -1;
}


///
/// Prepare thread for execution
///
/// Finds suitable slot and loads bitstreams, or waits until
/// a slot becomes free
///
void prep_exec(rthread_attr_t *hwt) {
#ifdef UPBFUN_RECONOS_PARTIAL
    int i, j;
    uint8 possible_slots[NUM_OSIFS];
    reconos_bitstream_t *possible_bitstreams[NUM_OSIFS];
    uint8 num_possible_slots = 0;

    if (hwt->flags & RTHREAD_ATTR_IS_DYNAMIC) {
        // find possible slots and bitstreams
        for (i = 0; i < NUM_OSIFS; i++) {
            for (j = 0; j < hwt->circuit->num_bitstreams; j++) {
                if (hwt->circuit->bitstreams[j]->slot_num == i) {
                    possible_slots[num_possible_slots] = i;
                    possible_bitstreams[num_possible_slots++] = 
                        hwt->circuit->bitstreams[j];
                }
            }
        }
        if (hwt->circuit->num_bitstreams == 0) {
            diag_printf("no bitstreams available for circuit '%s'\n",
                        hwt->circuit->name);
            cyg_thread_exit();
        }

        // find first free slot FIXME: schedule this better?
        if (!cyg_mutex_lock(&reconos_slots_mutex)) {
            CYG_FAIL("mutex lock failed, aborting thread\n");
        } else {

            while(( i = find_free_slot(possible_slots, num_possible_slots)) < 0) { 
                cyg_cond_wait(&reconos_slots_wait);
            }

            j = possible_slots[i];
            reconos_slots[j].state = RUNNING;
            // now, j = possible_slots[i] is the slot to use
            hwt->slot = &reconos_slots[j];
            hwt->slot->thread = hwt;

            cyg_mutex_unlock(&reconos_slots_mutex);

        }

        // disable bus macros (just in case)
        osif_set_busmacro(hwt, OSIF_DATA_BUSMACRO_DISABLE);
        // load bitstream
        DEBUG_PRINTF("loading bitstream for circuit '%s' into slot %d...",
            hwt->circuit->name, j);
        icap_load(possible_bitstreams[i]->data, possible_bitstreams[i]->size);
        DEBUG_PRINTF("done\n");

    } else // static thread

#endif // UPBFUN_RECONOS_PARTIAL
    {   
        if (!cyg_mutex_lock(&reconos_slots_mutex)) {
            CYG_FAIL("mutex lock failed, aborting thread\n");
        } else {
            CYG_ASSERT(hwt->slot, "no slot associated with static thread");
            while (hwt->slot->state != READY) {
                cyg_cond_wait(&reconos_slots_wait);
            }

            hwt->slot->state = RUNNING;
            hwt->slot->thread = hwt;
            cyg_mutex_unlock(&reconos_slots_mutex);
        }
    }
}            

**********************/

//-----------------------------------------
// eCos delegate thread
//-----------------------------------------
void
reconos_delegate_thread (cyg_addrword_t data)
{
  rthread_attr_t *hwt = (rthread_attr_t *) data;
  osif_task2os_t request;
  uint32 retval;
  char self_name[100];

#ifdef CYGPKG_KERNEL_THREADS_DESTRUCTORS
  cyg_bool_t result =
    cyg_thread_add_destructor (reconos_delegate_thread_destructor,
			       (cyg_addrword_t) hwt);
  CYG_ASSERT (result, "Failed to attach delegate thread destructor!");
#endif

#ifdef UPBDBG_RECONOS_DEBUG
  cyg_thread_info self_info;
  strncpy (self_name,
	   cyg_thread_get_info (cyg_thread_self (),
				cyg_thread_get_id (cyg_thread_self ()),
				&self_info) ? self_info.name : "UNKNOWN", 20);

  rthread_attr_dump (hwt);
#endif

  // prepare for execution
//        prep_exec(hwt);

#ifdef UPBFUN_RECONOS_PARTIAL
  // lock scheduling mutex
  if (!cyg_mutex_lock (&reconos_hwsched_mutex))
    {
      CYG_FAIL ("scheduling mutex lock failed, aborting thread\n");
    };

  // load hardware, if we're not static
  if (hwt->flags & RTHREAD_ATTR_IS_DYNAMIC)
    {
      DEBUG_PRINTF ("thread '%s': requesting bitstream load\n", self_name);
      // set RECONFIG flag
      hwt->flags |= RTHREAD_ATTR_RECONFIGURE;
      // signal hw scheduler
      cyg_semaphore_post (&reconos_hwsched_semaphore);
      // now wait until our circuit has been configured to the system
      while (hwt->slot == NULL)
	{
	  cyg_cond_wait (&reconos_hwsched_condvar);
	}
    }
  DEBUG_PRINTF ("thread '%s': setting slot state to RUNNING\n", self_name);
  hwt->slot->state = RUNNING;
  cyg_mutex_unlock (&reconos_hwsched_mutex);
#endif

  CYG_ASSERT (hwt->slot != NULL, "no slot to execute thread in");
  CYG_ASSERT (hwt == hwt->slot->thread, "thread->slot->thread links corrupt");

  // lock osif mutex
  if (!cyg_mutex_lock (&(hwt->slot->mutex)))
    {
      CYG_FAIL ("osif mutex lock failed, aborting thread\n");
    };

  // Reset HW thread
  DEBUG_PRINTF ("thread '%s': ", self_name);
  osif_reset (hwt->slot);

  // wait a little FIXME: does this impede performance?
  cyg_mutex_unlock (&(hwt->slot->mutex));
  cyg_thread_delay (1);
  if (!cyg_mutex_lock (&(hwt->slot->mutex)))
    {
      CYG_FAIL ("osif mutex lock failed, aborting thread\n");
    };

  // pass initialization data to hardware thread
  DEBUG_PRINTF ("thread '%s': ", self_name);
  osif_set_init_data (hwt->slot, hwt->init_data);

  // write local FIFO handles
  DEBUG_PRINTF ("thread '%s': ", self_name);
  osif_set_fifo_handles (hwt->slot, hwt->fifo_read_index,
			 hwt->fifo_write_index);

  // enable bus macros
  DEBUG_PRINTF ("thread '%s': ", self_name);
  osif_set_busmacro (hwt->slot, 1);

  // unblock hardware
  DEBUG_PRINTF ("thread '%s': ", self_name);
  osif_unblock (hwt->slot);

  cyg_mutex_unlock (&(hwt->slot->mutex));

  for (;;)
    {
      // wait for reconos delegate semaphore
      cyg_semaphore_wait (&(hwt->delegate_semaphore));

      // read command and data
      if (!cyg_mutex_lock (&(hwt->slot->mutex)))
	{
	  CYG_FAIL ("osif mutex lock failed, aborting thread\n");
	};
      DEBUG_PRINTF ("thread '%s': ", self_name);
      osif_read_call_parameters (hwt->slot, &request);
      cyg_mutex_unlock (&(hwt->slot->mutex));

#ifdef UPBFUN_RECONOS_PARTIAL
      if (request.command.flags & OSIF_FLAGS_YIELD)
	{
	  // this is a yielding call!
	  DEBUG_PRINTF ("thread '%s': yielding call!\n", self_name);
	  // lock scheduling mutex
	  if (!cyg_mutex_lock (&reconos_hwsched_mutex))
	    {
	      CYG_FAIL ("scheduling mutex lock failed, aborting thread\n");
	    };
	  // save context (TODO: not yet implemented!)
	  if (hwt->state_size > 0)
	    {
#ifdef UPBFUN_RECONOS_CACHE_BURST_RAM
	      // invalidate cache lines corresponding to burst RAM
	      // FIXME: memory offset is hardcoded!
	      HAL_DCACHE_INVALIDATE ((unsigned int) (hwt->slot->
						     plb_base_addr + 0x4000),
				     hwt->state_size);
#endif
	      // FIXME: memory offset is hardcoded!
	      memcpy (hwt->state_buf, hwt->slot->plb_base_addr + 0x4000,
		      hwt->state_size);
	    }
	  // save state
	  hwt->saved_command = request.command;	// this saves state and step
	  // hwt->saved_state_enc = request.command.saved_state_enc;

	  // set YIELD flag
	  hwt->flags |= RTHREAD_ATTR_YIELDS;
	  // unlock scheduling mutex
	  cyg_mutex_unlock (&reconos_hwsched_mutex);
	  // signal scheduling thread
	  cyg_semaphore_post (&reconos_hwsched_semaphore);
	}
#endif

      switch (request.command.code)
	{

	  //---------------------------------------------
	  // reconos_cond_broadcast
	  // generated from cond_broadcast.cmddef
	  //---------------------------------------------
	case OSIF_CMD_COND_BROADCAST:

	  CYG_ASSERT (request.data < hwt->resource_count,
		      "reconos_cond_broadcast operation requested on non-existing resource!");
	  switch (hwt->resources[request.data].type)
	    {

	      // ecos_ecos (CYG_COND_T) ------------------
	    case CYG_COND_T:
	      {
		cyg_cond_broadcast ((cyg_cond_t *) hwt->
				    resources[request.data].ptr);
	      }
	      break;

#ifdef UPBFUN_RECONOS_POSIX

	      // ecos_posix (PTHREAD_COND_T) ------------------
	    case PTHREAD_COND_T:
	      {
		pthread_cond_broadcast ((pthread_cond_t *) hwt->
					resources[request.data].ptr);
	      }
	      break;

#endif
	    default:
	      CYG_FAIL
		("reconos_cond_broadcast operation requested on invalid resource type!");
	    }



#ifdef UPBFUN_RECONOS_PARTIAL
	  if (request.command.flags & OSIF_FLAGS_YIELD)
	    {
	      // this was a yielding call!
	      // lock scheduling mutex
	      if (!cyg_mutex_lock (&reconos_hwsched_mutex))
		{
		  CYG_FAIL
		    ("scheduling mutex lock failed, aborting thread\n");
		};
	      // clear YIELD flag
	      hwt->flags &= ~RTHREAD_ATTR_YIELDS;
	      if (hwt->slot == NULL)
		{		// whoa! out hardware's not here
		  DEBUG_PRINTF ("thread '%s': requesting bitstream load\n",
				self_name);
		  // set RECONFIG flag
		  hwt->flags |= RTHREAD_ATTR_RECONFIGURE;
		  // signal hw scheduler
		  cyg_semaphore_post (&reconos_hwsched_semaphore);
		  // now wait until our circuit has been configured to the system
		  while (hwt->slot == NULL)
		    {
		      cyg_cond_wait (&reconos_hwsched_condvar);
		    }
		  hwt->slot->state = RUNNING;
		  // lock osif mutex
		  if (!cyg_mutex_lock (&(hwt->slot->mutex)))
		    {
		      CYG_FAIL ("osif mutex lock failed, aborting thread\n");
		    };
		  // reset osif
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_reset (hwt->slot);
		  // restore context (TODO: not yet implemented!)
		  if (hwt->state_size > 0)
		    {
		      memcpy (hwt->slot->plb_base_addr + 0x4000,
			      hwt->state_buf, hwt->state_size);
#ifdef UPBFUN_RECONOS_CACHE_BURST_RAM
		      // flush cache lines corresponding to burst RAM
		      // FIXME: memory offset is hardcoded!
		      HAL_DCACHE_FLUSH ((unsigned int) (hwt->slot->
							plb_base_addr +
							0x4000),
					hwt->state_size);
#endif
		    }
		  // restore fsm state
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_resume (hwt->slot, hwt->saved_command);	// sets resume state and step according to saved command
		  // pass initialization data to hardware thread
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_init_data (hwt->slot, hwt->init_data);
		  // write local FIFO handles
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_fifo_handles (hwt->slot, hwt->fifo_read_index,
					 hwt->fifo_write_index);
		  // enable bus macros
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_busmacro (hwt->slot, 1);
		  // unblock hardware
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_unblock (hwt->slot);
		  // unlock osif mutex
		  cyg_mutex_unlock (&(hwt->slot->mutex));
		}
	      // unlock scheduling mutex
	      cyg_mutex_unlock (&reconos_hwsched_mutex);
	    }
#endif

	  break;

	  //---------------------------------------------
	  // reconos_cond_signal
	  // generated from cond_signal.cmddef
	  //---------------------------------------------
	case OSIF_CMD_COND_SIGNAL:

	  CYG_ASSERT (request.data < hwt->resource_count,
		      "reconos_cond_signal operation requested on non-existing resource!");
	  switch (hwt->resources[request.data].type)
	    {

	      // ecos_ecos (CYG_COND_T) ------------------
	    case CYG_COND_T:
	      {
		cyg_cond_signal ((cyg_cond_t *) hwt->resources[request.data].
				 ptr);
	      }
	      break;

#ifdef UPBFUN_RECONOS_POSIX

	      // ecos_posix (PTHREAD_COND_T) ------------------
	    case PTHREAD_COND_T:
	      {
		pthread_cond_signal ((pthread_cond_t *) hwt->
				     resources[request.data].ptr);
	      }
	      break;

#endif
	    default:
	      CYG_FAIL
		("reconos_cond_signal operation requested on invalid resource type!");
	    }



#ifdef UPBFUN_RECONOS_PARTIAL
	  if (request.command.flags & OSIF_FLAGS_YIELD)
	    {
	      // this was a yielding call!
	      // lock scheduling mutex
	      if (!cyg_mutex_lock (&reconos_hwsched_mutex))
		{
		  CYG_FAIL
		    ("scheduling mutex lock failed, aborting thread\n");
		};
	      // clear YIELD flag
	      hwt->flags &= ~RTHREAD_ATTR_YIELDS;
	      if (hwt->slot == NULL)
		{		// whoa! out hardware's not here
		  DEBUG_PRINTF ("thread '%s': requesting bitstream load\n",
				self_name);
		  // set RECONFIG flag
		  hwt->flags |= RTHREAD_ATTR_RECONFIGURE;
		  // signal hw scheduler
		  cyg_semaphore_post (&reconos_hwsched_semaphore);
		  // now wait until our circuit has been configured to the system
		  while (hwt->slot == NULL)
		    {
		      cyg_cond_wait (&reconos_hwsched_condvar);
		    }
		  hwt->slot->state = RUNNING;
		  // lock osif mutex
		  if (!cyg_mutex_lock (&(hwt->slot->mutex)))
		    {
		      CYG_FAIL ("osif mutex lock failed, aborting thread\n");
		    };
		  // reset osif
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_reset (hwt->slot);
		  // restore context (TODO: not yet implemented!)
		  if (hwt->state_size > 0)
		    {
		      memcpy (hwt->slot->plb_base_addr + 0x4000,
			      hwt->state_buf, hwt->state_size);
#ifdef UPBFUN_RECONOS_CACHE_BURST_RAM
		      // flush cache lines corresponding to burst RAM
		      // FIXME: memory offset is hardcoded!
		      HAL_DCACHE_FLUSH ((unsigned int) (hwt->slot->
							plb_base_addr +
							0x4000),
					hwt->state_size);
#endif
		    }
		  // restore fsm state
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_resume (hwt->slot, hwt->saved_command);	// sets resume state and step according to saved command
		  // pass initialization data to hardware thread
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_init_data (hwt->slot, hwt->init_data);
		  // write local FIFO handles
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_fifo_handles (hwt->slot, hwt->fifo_read_index,
					 hwt->fifo_write_index);
		  // enable bus macros
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_busmacro (hwt->slot, 1);
		  // unblock hardware
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_unblock (hwt->slot);
		  // unlock osif mutex
		  cyg_mutex_unlock (&(hwt->slot->mutex));
		}
	      // unlock scheduling mutex
	      cyg_mutex_unlock (&reconos_hwsched_mutex);
	    }
#endif

	  break;

	  //---------------------------------------------
	  // reconos_cond_wait
	  // generated from cond_wait.cmddef
	  //---------------------------------------------
	case OSIF_CMD_COND_WAIT:

	  CYG_ASSERT (request.data < hwt->resource_count,
		      "reconos_cond_wait operation requested on non-existing resource!");
	  switch (hwt->resources[request.data].type)
	    {

	      // ecos_ecos (CYG_COND_T) ------------------
	    case CYG_COND_T:
	      {
		retval =
		  cyg_cond_wait ((cyg_cond_t *) hwt->resources[request.data].
				 ptr);
	      }
	      break;

#ifdef UPBFUN_RECONOS_POSIX

	      // ecos_posix (PTHREAD_COND_T) ------------------
	    case PTHREAD_COND_T:
	      {

		// FIXME: We currently assume that the mutex associated with this condvar is
		//        stored in the preceeding resource. This is dangerous.
		if (hwt->resources[request.data - 1].type != PTHREAD_MUTEX_T)
		  {
		    CYG_FAIL ("Mutex must precede CondVar.");
		  }
		retval =
		  !pthread_cond_wait ((pthread_cond_t *) hwt->
				      resources[request.data].ptr,
				      (pthread_mutex_t *) hwt->
				      resources[request.data - 1].ptr);

	      }
	      break;

#endif
	    default:
	      CYG_FAIL
		("reconos_cond_wait operation requested on invalid resource type!");
	    }



#ifdef UPBFUN_RECONOS_PARTIAL
	  if (request.command.flags & OSIF_FLAGS_YIELD)
	    {
	      // this was a yielding call!
	      // lock scheduling mutex
	      if (!cyg_mutex_lock (&reconos_hwsched_mutex))
		{
		  CYG_FAIL
		    ("scheduling mutex lock failed, aborting thread\n");
		};
	      // clear YIELD flag
	      hwt->flags &= ~RTHREAD_ATTR_YIELDS;
	      if (hwt->slot == NULL)
		{		// whoa! out hardware's not here
		  DEBUG_PRINTF ("thread '%s': requesting bitstream load\n",
				self_name);
		  // set RECONFIG flag
		  hwt->flags |= RTHREAD_ATTR_RECONFIGURE;
		  // signal hw scheduler
		  cyg_semaphore_post (&reconos_hwsched_semaphore);
		  // now wait until our circuit has been configured to the system
		  while (hwt->slot == NULL)
		    {
		      cyg_cond_wait (&reconos_hwsched_condvar);
		    }
		  hwt->slot->state = RUNNING;
		  // lock osif mutex
		  if (!cyg_mutex_lock (&(hwt->slot->mutex)))
		    {
		      CYG_FAIL ("osif mutex lock failed, aborting thread\n");
		    };
		  // reset osif
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_reset (hwt->slot);
		  // restore context (TODO: not yet implemented!)
		  if (hwt->state_size > 0)
		    {
		      memcpy (hwt->slot->plb_base_addr + 0x4000,
			      hwt->state_buf, hwt->state_size);
#ifdef UPBFUN_RECONOS_CACHE_BURST_RAM
		      // flush cache lines corresponding to burst RAM
		      // FIXME: memory offset is hardcoded!
		      HAL_DCACHE_FLUSH ((unsigned int) (hwt->slot->
							plb_base_addr +
							0x4000),
					hwt->state_size);
#endif
		    }
		  // restore fsm state
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_resume (hwt->slot, hwt->saved_command);	// sets resume state and step according to saved command
		  // pass initialization data to hardware thread
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_init_data (hwt->slot, hwt->init_data);
		  // write local FIFO handles
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_fifo_handles (hwt->slot, hwt->fifo_read_index,
					 hwt->fifo_write_index);
		  // enable bus macros
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_busmacro (hwt->slot, 1);
		  // unblock hardware
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_unblock (hwt->slot);
		  // unlock osif mutex
		  cyg_mutex_unlock (&(hwt->slot->mutex));
		}
	      // unlock scheduling mutex
	      cyg_mutex_unlock (&reconos_hwsched_mutex);
	    }
#endif

	  if (!cyg_mutex_lock (&(hwt->slot->mutex)))
	    {
	      CYG_FAIL ("osif mutex lock failed, aborting thread\n");
	    };
	  DEBUG_PRINTF ("thread '%s': ", self_name);
	  osif_write_result (hwt->slot, retval);
	  cyg_mutex_unlock (&(hwt->slot->mutex));
	  break;

	  //---------------------------------------------
	  // reconos_mbox_get
	  // generated from mbox_get.cmddef
	  //---------------------------------------------
	case OSIF_CMD_MBOX_GET:

	  CYG_ASSERT (request.data < hwt->resource_count,
		      "reconos_mbox_get operation requested on non-existing resource!");
	  switch (hwt->resources[request.data].type)
	    {

	      // ecos_ecos (CYG_MBOX_HANDLE_T) ------------------
	    case CYG_MBOX_HANDLE_T:
	      {
		retval =
		  (uint32)
		  cyg_mbox_get (*
				((cyg_handle_t *) hwt->
				 resources[request.data].ptr));
	      }
	      break;

#ifdef UPBFUN_RECONOS_POSIX

	      // ecos_posix (PTHREAD_MQD_T) ------------------
	    case PTHREAD_MQD_T:
	      {

		mqd_t q;
		char *mqname;
		struct mq_attr oldattr, newattr;

		mqname = hwt->resources[request.data].ptr;
		q = mq_open (mqname, O_RDWR);
		if (q == (mqd_t) (-1))
		  {
		    CYG_FAIL ("error opening posix mq for reading");
		    diag_printf
		      ("############## FAIL !!! ##################\\n");
		    break;
		  }
		// set queue to be blocking
		mq_getattr (q, &oldattr);
		newattr = oldattr;
		newattr.mq_flags = newattr.mq_flags & ~O_NONBLOCK;
		mq_setattr (q, &newattr, NULL);
		if (mq_receive (q, (char *) &retval, 4, 0) < 0)
		  {
		    diag_printf
		      ("############### failed to read from mbox\\n");
		    perror ("mq_receive");
		    retval = 0;	// signal error
		  }

		// restore old queue attributes
		mq_setattr (q, &oldattr, NULL);

	      }
	      break;

#endif
	    default:
	      CYG_FAIL
		("reconos_mbox_get operation requested on invalid resource type!");
	    }



#ifdef UPBFUN_RECONOS_PARTIAL
	  if (request.command.flags & OSIF_FLAGS_YIELD)
	    {
	      // this was a yielding call!
	      // lock scheduling mutex
	      if (!cyg_mutex_lock (&reconos_hwsched_mutex))
		{
		  CYG_FAIL
		    ("scheduling mutex lock failed, aborting thread\n");
		};
	      // clear YIELD flag
	      hwt->flags &= ~RTHREAD_ATTR_YIELDS;
	      if (hwt->slot == NULL)
		{		// whoa! out hardware's not here
		  DEBUG_PRINTF ("thread '%s': requesting bitstream load\n",
				self_name);
		  // set RECONFIG flag
		  hwt->flags |= RTHREAD_ATTR_RECONFIGURE;
		  // signal hw scheduler
		  cyg_semaphore_post (&reconos_hwsched_semaphore);
		  // now wait until our circuit has been configured to the system
		  while (hwt->slot == NULL)
		    {
		      cyg_cond_wait (&reconos_hwsched_condvar);
		    }
		  hwt->slot->state = RUNNING;
		  // lock osif mutex
		  if (!cyg_mutex_lock (&(hwt->slot->mutex)))
		    {
		      CYG_FAIL ("osif mutex lock failed, aborting thread\n");
		    };
		  // reset osif
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_reset (hwt->slot);
		  // restore context (TODO: not yet implemented!)
		  if (hwt->state_size > 0)
		    {
		      memcpy (hwt->slot->plb_base_addr + 0x4000,
			      hwt->state_buf, hwt->state_size);
#ifdef UPBFUN_RECONOS_CACHE_BURST_RAM
		      // flush cache lines corresponding to burst RAM
		      // FIXME: memory offset is hardcoded!
		      HAL_DCACHE_FLUSH ((unsigned int) (hwt->slot->
							plb_base_addr +
							0x4000),
					hwt->state_size);
#endif
		    }
		  // restore fsm state
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_resume (hwt->slot, hwt->saved_command);	// sets resume state and step according to saved command
		  // pass initialization data to hardware thread
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_init_data (hwt->slot, hwt->init_data);
		  // write local FIFO handles
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_fifo_handles (hwt->slot, hwt->fifo_read_index,
					 hwt->fifo_write_index);
		  // enable bus macros
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_busmacro (hwt->slot, 1);
		  // unblock hardware
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_unblock (hwt->slot);
		  // unlock osif mutex
		  cyg_mutex_unlock (&(hwt->slot->mutex));
		}
	      // unlock scheduling mutex
	      cyg_mutex_unlock (&reconos_hwsched_mutex);
	    }
#endif

	  if (!cyg_mutex_lock (&(hwt->slot->mutex)))
	    {
	      CYG_FAIL ("osif mutex lock failed, aborting thread\n");
	    };
	  DEBUG_PRINTF ("thread '%s': ", self_name);
	  osif_write_result (hwt->slot, retval);
	  cyg_mutex_unlock (&(hwt->slot->mutex));
	  break;

	  //---------------------------------------------
	  // reconos_mbox_put
	  // generated from mbox_put.cmddef
	  //---------------------------------------------
	case OSIF_CMD_MBOX_PUT:

	  CYG_ASSERT (request.data < hwt->resource_count,
		      "reconos_mbox_put operation requested on non-existing resource!");
	  switch (hwt->resources[request.data].type)
	    {

	      // ecos_ecos (CYG_MBOX_HANDLE_T) ------------------
	    case CYG_MBOX_HANDLE_T:
	      {
		retval =
		  (uint32)
		  cyg_mbox_put (*
				((cyg_handle_t *) hwt->
				 resources[request.data].ptr),
				(void *) request.datax);
	      }
	      break;

#ifdef UPBFUN_RECONOS_POSIX

	      // ecos_posix (PTHREAD_MQD_T) ------------------
	    case PTHREAD_MQD_T:
	      {

		mqd_t q;
		char *mqname;
		struct mq_attr oldattr, newattr;

		mqname = hwt->resources[request.data].ptr;
		q = mq_open (mqname, O_WRONLY);
		if (q == (mqd_t) (-1))
		  {
		    CYG_FAIL ("error opening posix mq for writing");
		    break;
		  }

		// set queue to be blocking
		mq_getattr (q, &oldattr);
		newattr = oldattr;
		newattr.mq_flags = newattr.mq_flags & ~O_NONBLOCK;
		mq_setattr (q, &newattr, NULL);
		if (mq_send (q, (char *) &request.datax, 4, 0) < 0)
		  {
		    retval = 0;	// signal error
		  }
		else
		  {
		    retval = 1;	// signal success
		  }
		// restore old queue attributes
		mq_setattr (q, &oldattr, NULL);

	      }
	      break;

#endif
	    default:
	      CYG_FAIL
		("reconos_mbox_put operation requested on invalid resource type!");
	    }



#ifdef UPBFUN_RECONOS_PARTIAL
	  if (request.command.flags & OSIF_FLAGS_YIELD)
	    {
	      // this was a yielding call!
	      // lock scheduling mutex
	      if (!cyg_mutex_lock (&reconos_hwsched_mutex))
		{
		  CYG_FAIL
		    ("scheduling mutex lock failed, aborting thread\n");
		};
	      // clear YIELD flag
	      hwt->flags &= ~RTHREAD_ATTR_YIELDS;
	      if (hwt->slot == NULL)
		{		// whoa! out hardware's not here
		  DEBUG_PRINTF ("thread '%s': requesting bitstream load\n",
				self_name);
		  // set RECONFIG flag
		  hwt->flags |= RTHREAD_ATTR_RECONFIGURE;
		  // signal hw scheduler
		  cyg_semaphore_post (&reconos_hwsched_semaphore);
		  // now wait until our circuit has been configured to the system
		  while (hwt->slot == NULL)
		    {
		      cyg_cond_wait (&reconos_hwsched_condvar);
		    }
		  hwt->slot->state = RUNNING;
		  // lock osif mutex
		  if (!cyg_mutex_lock (&(hwt->slot->mutex)))
		    {
		      CYG_FAIL ("osif mutex lock failed, aborting thread\n");
		    };
		  // reset osif
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_reset (hwt->slot);
		  // restore context (TODO: not yet implemented!)
		  if (hwt->state_size > 0)
		    {
		      memcpy (hwt->slot->plb_base_addr + 0x4000,
			      hwt->state_buf, hwt->state_size);
#ifdef UPBFUN_RECONOS_CACHE_BURST_RAM
		      // flush cache lines corresponding to burst RAM
		      // FIXME: memory offset is hardcoded!
		      HAL_DCACHE_FLUSH ((unsigned int) (hwt->slot->
							plb_base_addr +
							0x4000),
					hwt->state_size);
#endif
		    }
		  // restore fsm state
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_resume (hwt->slot, hwt->saved_command);	// sets resume state and step according to saved command
		  // pass initialization data to hardware thread
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_init_data (hwt->slot, hwt->init_data);
		  // write local FIFO handles
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_fifo_handles (hwt->slot, hwt->fifo_read_index,
					 hwt->fifo_write_index);
		  // enable bus macros
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_busmacro (hwt->slot, 1);
		  // unblock hardware
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_unblock (hwt->slot);
		  // unlock osif mutex
		  cyg_mutex_unlock (&(hwt->slot->mutex));
		}
	      // unlock scheduling mutex
	      cyg_mutex_unlock (&reconos_hwsched_mutex);
	    }
#endif

	  if (!cyg_mutex_lock (&(hwt->slot->mutex)))
	    {
	      CYG_FAIL ("osif mutex lock failed, aborting thread\n");
	    };
	  DEBUG_PRINTF ("thread '%s': ", self_name);
	  osif_write_result (hwt->slot, retval);
	  cyg_mutex_unlock (&(hwt->slot->mutex));
	  break;

	  //---------------------------------------------
	  // reconos_mbox_tryget
	  // generated from mbox_tryget.cmddef
	  //---------------------------------------------
	case OSIF_CMD_MBOX_TRYGET:

	  CYG_ASSERT (request.data < hwt->resource_count,
		      "reconos_mbox_tryget operation requested on non-existing resource!");
	  switch (hwt->resources[request.data].type)
	    {

	      // ecos_ecos (CYG_MBOX_HANDLE_T) ------------------
	    case CYG_MBOX_HANDLE_T:
	      {
		retval =
		  (uint32)
		  cyg_mbox_tryget (*
				   ((cyg_handle_t *) hwt->
				    resources[request.data].ptr));
	      }
	      break;

#ifdef UPBFUN_RECONOS_POSIX

	      // ecos_posix (PTHREAD_MQD_T) ------------------
	    case PTHREAD_MQD_T:
	      {

		mqd_t q;
		char *mqname;
		struct mq_attr oldattr, newattr;

		mqname = hwt->resources[request.data].ptr;
		q = mq_open (mqname, O_RDWR);
		if (q == (mqd_t) (-1))
		  {
		    CYG_FAIL ("error opening posix mq for reading");
		    diag_printf
		      ("############## FAIL !!! ##################\\n");
		    break;
		  }
		// set queue to be non-blocking
		mq_getattr (q, &oldattr);
		newattr = oldattr;
		newattr.mq_flags = newattr.mq_flags | O_NONBLOCK;
		mq_setattr (q, &newattr, NULL);
		if (mq_receive (q, (char *) &retval, 4, 0) < 0)
		  {
		    diag_printf
		      ("############### failed to read from mbox\\n");
		    perror ("mq_receive");
		    retval = 0;	// signal error
		  }

		// restore old queue attributes
		mq_setattr (q, &oldattr, NULL);

	      }
	      break;

#endif
	    default:
	      CYG_FAIL
		("reconos_mbox_tryget operation requested on invalid resource type!");
	    }



#ifdef UPBFUN_RECONOS_PARTIAL
	  if (request.command.flags & OSIF_FLAGS_YIELD)
	    {
	      // this was a yielding call!
	      // lock scheduling mutex
	      if (!cyg_mutex_lock (&reconos_hwsched_mutex))
		{
		  CYG_FAIL
		    ("scheduling mutex lock failed, aborting thread\n");
		};
	      // clear YIELD flag
	      hwt->flags &= ~RTHREAD_ATTR_YIELDS;
	      if (hwt->slot == NULL)
		{		// whoa! out hardware's not here
		  DEBUG_PRINTF ("thread '%s': requesting bitstream load\n",
				self_name);
		  // set RECONFIG flag
		  hwt->flags |= RTHREAD_ATTR_RECONFIGURE;
		  // signal hw scheduler
		  cyg_semaphore_post (&reconos_hwsched_semaphore);
		  // now wait until our circuit has been configured to the system
		  while (hwt->slot == NULL)
		    {
		      cyg_cond_wait (&reconos_hwsched_condvar);
		    }
		  hwt->slot->state = RUNNING;
		  // lock osif mutex
		  if (!cyg_mutex_lock (&(hwt->slot->mutex)))
		    {
		      CYG_FAIL ("osif mutex lock failed, aborting thread\n");
		    };
		  // reset osif
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_reset (hwt->slot);
		  // restore context (TODO: not yet implemented!)
		  if (hwt->state_size > 0)
		    {
		      memcpy (hwt->slot->plb_base_addr + 0x4000,
			      hwt->state_buf, hwt->state_size);
#ifdef UPBFUN_RECONOS_CACHE_BURST_RAM
		      // flush cache lines corresponding to burst RAM
		      // FIXME: memory offset is hardcoded!
		      HAL_DCACHE_FLUSH ((unsigned int) (hwt->slot->
							plb_base_addr +
							0x4000),
					hwt->state_size);
#endif
		    }
		  // restore fsm state
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_resume (hwt->slot, hwt->saved_command);	// sets resume state and step according to saved command
		  // pass initialization data to hardware thread
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_init_data (hwt->slot, hwt->init_data);
		  // write local FIFO handles
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_fifo_handles (hwt->slot, hwt->fifo_read_index,
					 hwt->fifo_write_index);
		  // enable bus macros
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_busmacro (hwt->slot, 1);
		  // unblock hardware
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_unblock (hwt->slot);
		  // unlock osif mutex
		  cyg_mutex_unlock (&(hwt->slot->mutex));
		}
	      // unlock scheduling mutex
	      cyg_mutex_unlock (&reconos_hwsched_mutex);
	    }
#endif

	  if (!cyg_mutex_lock (&(hwt->slot->mutex)))
	    {
	      CYG_FAIL ("osif mutex lock failed, aborting thread\n");
	    };
	  DEBUG_PRINTF ("thread '%s': ", self_name);
	  osif_write_result (hwt->slot, retval);
	  cyg_mutex_unlock (&(hwt->slot->mutex));
	  break;

	  //---------------------------------------------
	  // reconos_mq_receive
	  // generated from mq_receive.cmddef
	  //---------------------------------------------
	case OSIF_CMD_MQ_RECEIVE:

	  CYG_ASSERT (request.data < hwt->resource_count,
		      "reconos_mq_receive operation requested on non-existing resource!");
	  switch (hwt->resources[request.data].type)
	    {
#ifdef UPBFUN_RECONOS_POSIX

	      // ecos_posix (PTHREAD_MQD_T) ------------------
	    case PTHREAD_MQD_T:
	      {

		mqd_t q;
		char *mqname;
		struct mq_attr oldattr, newattr;
		unsigned int msg_size;
		unsigned int msg_offset;
		char *msg;

		mqname = hwt->resources[request.data].ptr;
		msg_size = request.datax & 0xFFFF;
		msg_offset = request.datax >> 16;
		q = mq_open (mqname, O_RDWR);
		if (q == (mqd_t) (-1))
		  {
		    CYG_FAIL ("error opening posix mq for writing");
		    break;
		  }

		// set queue to be blocking
		// FIXME: memory offset is hardcoded!
		msg =
		  (char *) (hwt->slot->plb_base_addr + 0x4000 + msg_offset);
		mq_getattr (q, &oldattr);
		newattr = oldattr;
		newattr.mq_flags = newattr.mq_flags & ~O_NONBLOCK;
		mq_setattr (q, &newattr, NULL);
#ifdef HWTHREAD_DEBUG
		diag_printf
		  ("MQ_RECEIVE: &msg = 0x%08X, msgsize = 0x%08X, offset = 0x%08X\\n",
		   (unsigned int) msg, msg_size, msg_offset);
#endif

		if ((retval = mq_receive (q, msg, newattr.mq_msgsize, 0)) < 0)
		  {
		    perror ("mq_receive");
		    retval = 0;	// signal error
		  }

#ifdef UPBFUN_RECONOS_CACHE_BURST_RAM
		// flush cache lines corresponding to burst RAM
		// FIXME: memory offset is hardcoded!
		HAL_DCACHE_FLUSH ((unsigned int) msg, newattr.mq_msgsize);
#endif

		// restore old queue attributes
		mq_setattr (q, &oldattr, NULL);

	      }
	      break;

#endif
	    default:
	      CYG_FAIL
		("reconos_mq_receive operation requested on invalid resource type!");
	    }



#ifdef UPBFUN_RECONOS_PARTIAL
	  if (request.command.flags & OSIF_FLAGS_YIELD)
	    {
	      // this was a yielding call!
	      // lock scheduling mutex
	      if (!cyg_mutex_lock (&reconos_hwsched_mutex))
		{
		  CYG_FAIL
		    ("scheduling mutex lock failed, aborting thread\n");
		};
	      // clear YIELD flag
	      hwt->flags &= ~RTHREAD_ATTR_YIELDS;
	      if (hwt->slot == NULL)
		{		// whoa! out hardware's not here
		  DEBUG_PRINTF ("thread '%s': requesting bitstream load\n",
				self_name);
		  // set RECONFIG flag
		  hwt->flags |= RTHREAD_ATTR_RECONFIGURE;
		  // signal hw scheduler
		  cyg_semaphore_post (&reconos_hwsched_semaphore);
		  // now wait until our circuit has been configured to the system
		  while (hwt->slot == NULL)
		    {
		      cyg_cond_wait (&reconos_hwsched_condvar);
		    }
		  hwt->slot->state = RUNNING;
		  // lock osif mutex
		  if (!cyg_mutex_lock (&(hwt->slot->mutex)))
		    {
		      CYG_FAIL ("osif mutex lock failed, aborting thread\n");
		    };
		  // reset osif
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_reset (hwt->slot);
		  // restore context (TODO: not yet implemented!)
		  if (hwt->state_size > 0)
		    {
		      memcpy (hwt->slot->plb_base_addr + 0x4000,
			      hwt->state_buf, hwt->state_size);
#ifdef UPBFUN_RECONOS_CACHE_BURST_RAM
		      // flush cache lines corresponding to burst RAM
		      // FIXME: memory offset is hardcoded!
		      HAL_DCACHE_FLUSH ((unsigned int) (hwt->slot->
							plb_base_addr +
							0x4000),
					hwt->state_size);
#endif
		    }
		  // restore fsm state
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_resume (hwt->slot, hwt->saved_command);	// sets resume state and step according to saved command
		  // pass initialization data to hardware thread
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_init_data (hwt->slot, hwt->init_data);
		  // write local FIFO handles
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_fifo_handles (hwt->slot, hwt->fifo_read_index,
					 hwt->fifo_write_index);
		  // enable bus macros
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_busmacro (hwt->slot, 1);
		  // unblock hardware
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_unblock (hwt->slot);
		  // unlock osif mutex
		  cyg_mutex_unlock (&(hwt->slot->mutex));
		}
	      // unlock scheduling mutex
	      cyg_mutex_unlock (&reconos_hwsched_mutex);
	    }
#endif

	  if (!cyg_mutex_lock (&(hwt->slot->mutex)))
	    {
	      CYG_FAIL ("osif mutex lock failed, aborting thread\n");
	    };
	  DEBUG_PRINTF ("thread '%s': ", self_name);
	  osif_write_result (hwt->slot, retval);
	  cyg_mutex_unlock (&(hwt->slot->mutex));
	  break;

	  //---------------------------------------------
	  // reconos_mq_send
	  // generated from mq_send.cmddef
	  //---------------------------------------------
	case OSIF_CMD_MQ_SEND:

	  CYG_ASSERT (request.data < hwt->resource_count,
		      "reconos_mq_send operation requested on non-existing resource!");
	  switch (hwt->resources[request.data].type)
	    {
#ifdef UPBFUN_RECONOS_POSIX

	      // ecos_posix (PTHREAD_MQD_T) ------------------
	    case PTHREAD_MQD_T:
	      {

		mqd_t q;
		char *mqname;
		struct mq_attr oldattr, newattr;
		unsigned int msg_size;
		unsigned int msg_offset;
		char *msg;

		mqname = hwt->resources[request.data].ptr;
		msg_size = request.datax & 0xFFFF;
		msg_offset = request.datax >> 16;
		q = mq_open (mqname, O_RDWR);
		if (q == (mqd_t) (-1))
		  {
		    CYG_FAIL ("error opening posix mq for writing");
		    break;
		  }

		// set queue to be blocking
		// FIXME: memory offset is hardcoded!
		msg =
		  (char *) (hwt->slot->plb_base_addr + 0x4000 + msg_offset);
		mq_getattr (q, &oldattr);
		newattr = oldattr;
		newattr.mq_flags = newattr.mq_flags & ~O_NONBLOCK;
		mq_setattr (q, &newattr, NULL);
#ifdef HWTHREAD_DEBUG
		diag_printf
		  ("MQ_SEND: &msg = 0x%08X, msgsize = 0x%08X, offset = 0x%08X\\n",
		   (unsigned int) msg, msg_size, msg_offset);
#endif

#ifdef UPBFUN_RECONOS_CACHE_BURST_RAM
		// invalidate cache lines corresponding to burst RAM
		// FIXME: memory offset is hardcoded!
		HAL_DCACHE_INVALIDATE ((unsigned int) msg, msg_size);
#endif

		if (mq_send (q, msg, msg_size, 0) < 0)
		  {
		    retval = 0;	// signal error
		  }
		else
		  {
		    retval = 1;	// signal success
		  }
		// restore old queue attributes
		mq_setattr (q, &oldattr, NULL);

	      }
	      break;

#endif
	    default:
	      CYG_FAIL
		("reconos_mq_send operation requested on invalid resource type!");
	    }



#ifdef UPBFUN_RECONOS_PARTIAL
	  if (request.command.flags & OSIF_FLAGS_YIELD)
	    {
	      // this was a yielding call!
	      // lock scheduling mutex
	      if (!cyg_mutex_lock (&reconos_hwsched_mutex))
		{
		  CYG_FAIL
		    ("scheduling mutex lock failed, aborting thread\n");
		};
	      // clear YIELD flag
	      hwt->flags &= ~RTHREAD_ATTR_YIELDS;
	      if (hwt->slot == NULL)
		{		// whoa! out hardware's not here
		  DEBUG_PRINTF ("thread '%s': requesting bitstream load\n",
				self_name);
		  // set RECONFIG flag
		  hwt->flags |= RTHREAD_ATTR_RECONFIGURE;
		  // signal hw scheduler
		  cyg_semaphore_post (&reconos_hwsched_semaphore);
		  // now wait until our circuit has been configured to the system
		  while (hwt->slot == NULL)
		    {
		      cyg_cond_wait (&reconos_hwsched_condvar);
		    }
		  hwt->slot->state = RUNNING;
		  // lock osif mutex
		  if (!cyg_mutex_lock (&(hwt->slot->mutex)))
		    {
		      CYG_FAIL ("osif mutex lock failed, aborting thread\n");
		    };
		  // reset osif
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_reset (hwt->slot);
		  // restore context (TODO: not yet implemented!)
		  if (hwt->state_size > 0)
		    {
		      memcpy (hwt->slot->plb_base_addr + 0x4000,
			      hwt->state_buf, hwt->state_size);
#ifdef UPBFUN_RECONOS_CACHE_BURST_RAM
		      // flush cache lines corresponding to burst RAM
		      // FIXME: memory offset is hardcoded!
		      HAL_DCACHE_FLUSH ((unsigned int) (hwt->slot->
							plb_base_addr +
							0x4000),
					hwt->state_size);
#endif
		    }
		  // restore fsm state
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_resume (hwt->slot, hwt->saved_command);	// sets resume state and step according to saved command
		  // pass initialization data to hardware thread
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_init_data (hwt->slot, hwt->init_data);
		  // write local FIFO handles
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_fifo_handles (hwt->slot, hwt->fifo_read_index,
					 hwt->fifo_write_index);
		  // enable bus macros
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_busmacro (hwt->slot, 1);
		  // unblock hardware
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_unblock (hwt->slot);
		  // unlock osif mutex
		  cyg_mutex_unlock (&(hwt->slot->mutex));
		}
	      // unlock scheduling mutex
	      cyg_mutex_unlock (&reconos_hwsched_mutex);
	    }
#endif

	  if (!cyg_mutex_lock (&(hwt->slot->mutex)))
	    {
	      CYG_FAIL ("osif mutex lock failed, aborting thread\n");
	    };
	  DEBUG_PRINTF ("thread '%s': ", self_name);
	  osif_write_result (hwt->slot, retval);
	  cyg_mutex_unlock (&(hwt->slot->mutex));
	  break;

	  //---------------------------------------------
	  // reconos_mutex_lock
	  // generated from mutex_lock.cmddef
	  //---------------------------------------------
	case OSIF_CMD_MUTEX_LOCK:

	  CYG_ASSERT (request.data < hwt->resource_count,
		      "reconos_mutex_lock operation requested on non-existing resource!");
	  switch (hwt->resources[request.data].type)
	    {

	      // ecos_ecos (CYG_MUTEX_T) ------------------
	    case CYG_MUTEX_T:
	      {
		retval =
		  (uint32) cyg_mutex_lock ((cyg_mutex_t *) hwt->
					   resources[request.data].ptr);
	      }
	      break;

#ifdef UPBFUN_RECONOS_POSIX

	      // ecos_posix (PTHREAD_MUTEX_T) ------------------
	    case PTHREAD_MUTEX_T:
	      {
		retval =
		  pthread_mutex_lock ((pthread_mutex_t *) hwt->
				      resources[request.data].ptr);
	      }
	      break;

#endif
	    default:
	      CYG_FAIL
		("reconos_mutex_lock operation requested on invalid resource type!");
	    }



#ifdef UPBFUN_RECONOS_PARTIAL
	  if (request.command.flags & OSIF_FLAGS_YIELD)
	    {
	      // this was a yielding call!
	      // lock scheduling mutex
	      if (!cyg_mutex_lock (&reconos_hwsched_mutex))
		{
		  CYG_FAIL
		    ("scheduling mutex lock failed, aborting thread\n");
		};
	      // clear YIELD flag
	      hwt->flags &= ~RTHREAD_ATTR_YIELDS;
	      if (hwt->slot == NULL)
		{		// whoa! out hardware's not here
		  DEBUG_PRINTF ("thread '%s': requesting bitstream load\n",
				self_name);
		  // set RECONFIG flag
		  hwt->flags |= RTHREAD_ATTR_RECONFIGURE;
		  // signal hw scheduler
		  cyg_semaphore_post (&reconos_hwsched_semaphore);
		  // now wait until our circuit has been configured to the system
		  while (hwt->slot == NULL)
		    {
		      cyg_cond_wait (&reconos_hwsched_condvar);
		    }
		  hwt->slot->state = RUNNING;
		  // lock osif mutex
		  if (!cyg_mutex_lock (&(hwt->slot->mutex)))
		    {
		      CYG_FAIL ("osif mutex lock failed, aborting thread\n");
		    };
		  // reset osif
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_reset (hwt->slot);
		  // restore context (TODO: not yet implemented!)
		  if (hwt->state_size > 0)
		    {
		      memcpy (hwt->slot->plb_base_addr + 0x4000,
			      hwt->state_buf, hwt->state_size);
#ifdef UPBFUN_RECONOS_CACHE_BURST_RAM
		      // flush cache lines corresponding to burst RAM
		      // FIXME: memory offset is hardcoded!
		      HAL_DCACHE_FLUSH ((unsigned int) (hwt->slot->
							plb_base_addr +
							0x4000),
					hwt->state_size);
#endif
		    }
		  // restore fsm state
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_resume (hwt->slot, hwt->saved_command);	// sets resume state and step according to saved command
		  // pass initialization data to hardware thread
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_init_data (hwt->slot, hwt->init_data);
		  // write local FIFO handles
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_fifo_handles (hwt->slot, hwt->fifo_read_index,
					 hwt->fifo_write_index);
		  // enable bus macros
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_busmacro (hwt->slot, 1);
		  // unblock hardware
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_unblock (hwt->slot);
		  // unlock osif mutex
		  cyg_mutex_unlock (&(hwt->slot->mutex));
		}
	      // unlock scheduling mutex
	      cyg_mutex_unlock (&reconos_hwsched_mutex);
	    }
#endif

	  if (!cyg_mutex_lock (&(hwt->slot->mutex)))
	    {
	      CYG_FAIL ("osif mutex lock failed, aborting thread\n");
	    };
	  DEBUG_PRINTF ("thread '%s': ", self_name);
	  osif_write_result (hwt->slot, retval);
	  cyg_mutex_unlock (&(hwt->slot->mutex));
	  break;

	  //---------------------------------------------
	  // reconos_mutex_release
	  // generated from mutex_release.cmddef
	  //---------------------------------------------
	case OSIF_CMD_MUTEX_RELEASE:

	  CYG_ASSERT (request.data < hwt->resource_count,
		      "reconos_mutex_release operation requested on non-existing resource!");
	  switch (hwt->resources[request.data].type)
	    {

	      // ecos_ecos (CYG_MUTEX_T) ------------------
	    case CYG_MUTEX_T:
	      {
		cyg_mutex_release ((cyg_mutex_t *) hwt->
				   resources[request.data].ptr);
	      }
	      break;

	    default:
	      CYG_FAIL
		("reconos_mutex_release operation requested on invalid resource type!");
	    }



#ifdef UPBFUN_RECONOS_PARTIAL
	  if (request.command.flags & OSIF_FLAGS_YIELD)
	    {
	      // this was a yielding call!
	      // lock scheduling mutex
	      if (!cyg_mutex_lock (&reconos_hwsched_mutex))
		{
		  CYG_FAIL
		    ("scheduling mutex lock failed, aborting thread\n");
		};
	      // clear YIELD flag
	      hwt->flags &= ~RTHREAD_ATTR_YIELDS;
	      if (hwt->slot == NULL)
		{		// whoa! out hardware's not here
		  DEBUG_PRINTF ("thread '%s': requesting bitstream load\n",
				self_name);
		  // set RECONFIG flag
		  hwt->flags |= RTHREAD_ATTR_RECONFIGURE;
		  // signal hw scheduler
		  cyg_semaphore_post (&reconos_hwsched_semaphore);
		  // now wait until our circuit has been configured to the system
		  while (hwt->slot == NULL)
		    {
		      cyg_cond_wait (&reconos_hwsched_condvar);
		    }
		  hwt->slot->state = RUNNING;
		  // lock osif mutex
		  if (!cyg_mutex_lock (&(hwt->slot->mutex)))
		    {
		      CYG_FAIL ("osif mutex lock failed, aborting thread\n");
		    };
		  // reset osif
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_reset (hwt->slot);
		  // restore context (TODO: not yet implemented!)
		  if (hwt->state_size > 0)
		    {
		      memcpy (hwt->slot->plb_base_addr + 0x4000,
			      hwt->state_buf, hwt->state_size);
#ifdef UPBFUN_RECONOS_CACHE_BURST_RAM
		      // flush cache lines corresponding to burst RAM
		      // FIXME: memory offset is hardcoded!
		      HAL_DCACHE_FLUSH ((unsigned int) (hwt->slot->
							plb_base_addr +
							0x4000),
					hwt->state_size);
#endif
		    }
		  // restore fsm state
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_resume (hwt->slot, hwt->saved_command);	// sets resume state and step according to saved command
		  // pass initialization data to hardware thread
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_init_data (hwt->slot, hwt->init_data);
		  // write local FIFO handles
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_fifo_handles (hwt->slot, hwt->fifo_read_index,
					 hwt->fifo_write_index);
		  // enable bus macros
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_busmacro (hwt->slot, 1);
		  // unblock hardware
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_unblock (hwt->slot);
		  // unlock osif mutex
		  cyg_mutex_unlock (&(hwt->slot->mutex));
		}
	      // unlock scheduling mutex
	      cyg_mutex_unlock (&reconos_hwsched_mutex);
	    }
#endif

	  break;

	  //---------------------------------------------
	  // reconos_mutex_trylock
	  // generated from mutex_trylock.cmddef
	  //---------------------------------------------
	case OSIF_CMD_MUTEX_TRYLOCK:

	  CYG_ASSERT (request.data < hwt->resource_count,
		      "reconos_mutex_trylock operation requested on non-existing resource!");
	  switch (hwt->resources[request.data].type)
	    {

	      // ecos_ecos (CYG_MUTEX_T) ------------------
	    case CYG_MUTEX_T:
	      {
		retval =
		  (uint32) cyg_mutex_trylock ((cyg_mutex_t *) hwt->
					      resources[request.data].ptr);
	      }
	      break;

#ifdef UPBFUN_RECONOS_POSIX

	      // ecos_posix (PTHREAD_MUTEX_T) ------------------
	    case PTHREAD_MUTEX_T:
	      {
		retval =
		  pthread_mutex_trylock ((pthread_mutex_t *) hwt->
					 resources[request.data].ptr);
	      }
	      break;

#endif
	    default:
	      CYG_FAIL
		("reconos_mutex_trylock operation requested on invalid resource type!");
	    }



#ifdef UPBFUN_RECONOS_PARTIAL
	  if (request.command.flags & OSIF_FLAGS_YIELD)
	    {
	      // this was a yielding call!
	      // lock scheduling mutex
	      if (!cyg_mutex_lock (&reconos_hwsched_mutex))
		{
		  CYG_FAIL
		    ("scheduling mutex lock failed, aborting thread\n");
		};
	      // clear YIELD flag
	      hwt->flags &= ~RTHREAD_ATTR_YIELDS;
	      if (hwt->slot == NULL)
		{		// whoa! out hardware's not here
		  DEBUG_PRINTF ("thread '%s': requesting bitstream load\n",
				self_name);
		  // set RECONFIG flag
		  hwt->flags |= RTHREAD_ATTR_RECONFIGURE;
		  // signal hw scheduler
		  cyg_semaphore_post (&reconos_hwsched_semaphore);
		  // now wait until our circuit has been configured to the system
		  while (hwt->slot == NULL)
		    {
		      cyg_cond_wait (&reconos_hwsched_condvar);
		    }
		  hwt->slot->state = RUNNING;
		  // lock osif mutex
		  if (!cyg_mutex_lock (&(hwt->slot->mutex)))
		    {
		      CYG_FAIL ("osif mutex lock failed, aborting thread\n");
		    };
		  // reset osif
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_reset (hwt->slot);
		  // restore context (TODO: not yet implemented!)
		  if (hwt->state_size > 0)
		    {
		      memcpy (hwt->slot->plb_base_addr + 0x4000,
			      hwt->state_buf, hwt->state_size);
#ifdef UPBFUN_RECONOS_CACHE_BURST_RAM
		      // flush cache lines corresponding to burst RAM
		      // FIXME: memory offset is hardcoded!
		      HAL_DCACHE_FLUSH ((unsigned int) (hwt->slot->
							plb_base_addr +
							0x4000),
					hwt->state_size);
#endif
		    }
		  // restore fsm state
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_resume (hwt->slot, hwt->saved_command);	// sets resume state and step according to saved command
		  // pass initialization data to hardware thread
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_init_data (hwt->slot, hwt->init_data);
		  // write local FIFO handles
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_fifo_handles (hwt->slot, hwt->fifo_read_index,
					 hwt->fifo_write_index);
		  // enable bus macros
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_busmacro (hwt->slot, 1);
		  // unblock hardware
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_unblock (hwt->slot);
		  // unlock osif mutex
		  cyg_mutex_unlock (&(hwt->slot->mutex));
		}
	      // unlock scheduling mutex
	      cyg_mutex_unlock (&reconos_hwsched_mutex);
	    }
#endif

	  if (!cyg_mutex_lock (&(hwt->slot->mutex)))
	    {
	      CYG_FAIL ("osif mutex lock failed, aborting thread\n");
	    };
	  DEBUG_PRINTF ("thread '%s': ", self_name);
	  osif_write_result (hwt->slot, retval);
	  cyg_mutex_unlock (&(hwt->slot->mutex));
	  break;

	  //---------------------------------------------
	  // reconos_mutex_unlock
	  // generated from mutex_unlock.cmddef
	  //---------------------------------------------
	case OSIF_CMD_MUTEX_UNLOCK:

	  CYG_ASSERT (request.data < hwt->resource_count,
		      "reconos_mutex_unlock operation requested on non-existing resource!");
	  switch (hwt->resources[request.data].type)
	    {

	      // ecos_ecos (CYG_MUTEX_T) ------------------
	    case CYG_MUTEX_T:
	      {
		cyg_mutex_unlock ((cyg_mutex_t *) hwt->
				  resources[request.data].ptr);
	      }
	      break;

#ifdef UPBFUN_RECONOS_POSIX

	      // ecos_posix (PTHREAD_MUTEX_T) ------------------
	    case PTHREAD_MUTEX_T:
	      {
		pthread_mutex_unlock ((pthread_mutex_t *) hwt->
				      resources[request.data].ptr);
	      }
	      break;

#endif
	    default:
	      CYG_FAIL
		("reconos_mutex_unlock operation requested on invalid resource type!");
	    }



#ifdef UPBFUN_RECONOS_PARTIAL
	  if (request.command.flags & OSIF_FLAGS_YIELD)
	    {
	      // this was a yielding call!
	      // lock scheduling mutex
	      if (!cyg_mutex_lock (&reconos_hwsched_mutex))
		{
		  CYG_FAIL
		    ("scheduling mutex lock failed, aborting thread\n");
		};
	      // clear YIELD flag
	      hwt->flags &= ~RTHREAD_ATTR_YIELDS;
	      if (hwt->slot == NULL)
		{		// whoa! out hardware's not here
		  DEBUG_PRINTF ("thread '%s': requesting bitstream load\n",
				self_name);
		  // set RECONFIG flag
		  hwt->flags |= RTHREAD_ATTR_RECONFIGURE;
		  // signal hw scheduler
		  cyg_semaphore_post (&reconos_hwsched_semaphore);
		  // now wait until our circuit has been configured to the system
		  while (hwt->slot == NULL)
		    {
		      cyg_cond_wait (&reconos_hwsched_condvar);
		    }
		  hwt->slot->state = RUNNING;
		  // lock osif mutex
		  if (!cyg_mutex_lock (&(hwt->slot->mutex)))
		    {
		      CYG_FAIL ("osif mutex lock failed, aborting thread\n");
		    };
		  // reset osif
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_reset (hwt->slot);
		  // restore context (TODO: not yet implemented!)
		  if (hwt->state_size > 0)
		    {
		      memcpy (hwt->slot->plb_base_addr + 0x4000,
			      hwt->state_buf, hwt->state_size);
#ifdef UPBFUN_RECONOS_CACHE_BURST_RAM
		      // flush cache lines corresponding to burst RAM
		      // FIXME: memory offset is hardcoded!
		      HAL_DCACHE_FLUSH ((unsigned int) (hwt->slot->
							plb_base_addr +
							0x4000),
					hwt->state_size);
#endif
		    }
		  // restore fsm state
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_resume (hwt->slot, hwt->saved_command);	// sets resume state and step according to saved command
		  // pass initialization data to hardware thread
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_init_data (hwt->slot, hwt->init_data);
		  // write local FIFO handles
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_fifo_handles (hwt->slot, hwt->fifo_read_index,
					 hwt->fifo_write_index);
		  // enable bus macros
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_busmacro (hwt->slot, 1);
		  // unblock hardware
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_unblock (hwt->slot);
		  // unlock osif mutex
		  cyg_mutex_unlock (&(hwt->slot->mutex));
		}
	      // unlock scheduling mutex
	      cyg_mutex_unlock (&reconos_hwsched_mutex);
	    }
#endif

	  break;

	  //---------------------------------------------
	  // reconos_semaphore_post
	  // generated from sem_post.cmddef
	  //---------------------------------------------
	case OSIF_CMD_SEM_POST:

	  CYG_ASSERT (request.data < hwt->resource_count,
		      "reconos_semaphore_post operation requested on non-existing resource!");
	  switch (hwt->resources[request.data].type)
	    {

	      // ecos_ecos (CYG_SEM_T) ------------------
	    case CYG_SEM_T:
	      {
		cyg_semaphore_post ((cyg_sem_t *) hwt->
				    resources[request.data].ptr);
	      }
	      break;

#ifdef UPBFUN_RECONOS_POSIX

	      // ecos_posix (PTHREAD_SEM_T) ------------------
	    case PTHREAD_SEM_T:
	      {
		sem_post ((sem_t *) hwt->resources[request.data].ptr);
	      }
	      break;

#endif
	    default:
	      CYG_FAIL
		("reconos_semaphore_post operation requested on invalid resource type!");
	    }



#ifdef UPBFUN_RECONOS_PARTIAL
	  if (request.command.flags & OSIF_FLAGS_YIELD)
	    {
	      // this was a yielding call!
	      // lock scheduling mutex
	      if (!cyg_mutex_lock (&reconos_hwsched_mutex))
		{
		  CYG_FAIL
		    ("scheduling mutex lock failed, aborting thread\n");
		};
	      // clear YIELD flag
	      hwt->flags &= ~RTHREAD_ATTR_YIELDS;
	      if (hwt->slot == NULL)
		{		// whoa! out hardware's not here
		  DEBUG_PRINTF ("thread '%s': requesting bitstream load\n",
				self_name);
		  // set RECONFIG flag
		  hwt->flags |= RTHREAD_ATTR_RECONFIGURE;
		  // signal hw scheduler
		  cyg_semaphore_post (&reconos_hwsched_semaphore);
		  // now wait until our circuit has been configured to the system
		  while (hwt->slot == NULL)
		    {
		      cyg_cond_wait (&reconos_hwsched_condvar);
		    }
		  hwt->slot->state = RUNNING;
		  // lock osif mutex
		  if (!cyg_mutex_lock (&(hwt->slot->mutex)))
		    {
		      CYG_FAIL ("osif mutex lock failed, aborting thread\n");
		    };
		  // reset osif
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_reset (hwt->slot);
		  // restore context (TODO: not yet implemented!)
		  if (hwt->state_size > 0)
		    {
		      memcpy (hwt->slot->plb_base_addr + 0x4000,
			      hwt->state_buf, hwt->state_size);
#ifdef UPBFUN_RECONOS_CACHE_BURST_RAM
		      // flush cache lines corresponding to burst RAM
		      // FIXME: memory offset is hardcoded!
		      HAL_DCACHE_FLUSH ((unsigned int) (hwt->slot->
							plb_base_addr +
							0x4000),
					hwt->state_size);
#endif
		    }
		  // restore fsm state
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_resume (hwt->slot, hwt->saved_command);	// sets resume state and step according to saved command
		  // pass initialization data to hardware thread
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_init_data (hwt->slot, hwt->init_data);
		  // write local FIFO handles
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_fifo_handles (hwt->slot, hwt->fifo_read_index,
					 hwt->fifo_write_index);
		  // enable bus macros
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_busmacro (hwt->slot, 1);
		  // unblock hardware
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_unblock (hwt->slot);
		  // unlock osif mutex
		  cyg_mutex_unlock (&(hwt->slot->mutex));
		}
	      // unlock scheduling mutex
	      cyg_mutex_unlock (&reconos_hwsched_mutex);
	    }
#endif

	  break;

	  //---------------------------------------------
	  // reconos_semaphore_wait
	  // generated from sem_wait.cmddef
	  //---------------------------------------------
	case OSIF_CMD_SEM_WAIT:

	  CYG_ASSERT (request.data < hwt->resource_count,
		      "reconos_semaphore_wait operation requested on non-existing resource!");
	  switch (hwt->resources[request.data].type)
	    {

	      // ecos_ecos (CYG_SEM_T) ------------------
	    case CYG_SEM_T:
	      {
		cyg_semaphore_wait ((cyg_sem_t *) hwt->
				    resources[request.data].ptr);
	      }
	      break;

#ifdef UPBFUN_RECONOS_POSIX

	      // ecos_posix (PTHREAD_SEM_T) ------------------
	    case PTHREAD_SEM_T:
	      {
		sem_wait ((sem_t *) hwt->resources[request.data].ptr);
	      }
	      break;

#endif
	    default:
	      CYG_FAIL
		("reconos_semaphore_wait operation requested on invalid resource type!");
	    }



#ifdef UPBFUN_RECONOS_PARTIAL
	  if (request.command.flags & OSIF_FLAGS_YIELD)
	    {
	      // this was a yielding call!
	      // lock scheduling mutex
	      if (!cyg_mutex_lock (&reconos_hwsched_mutex))
		{
		  CYG_FAIL
		    ("scheduling mutex lock failed, aborting thread\n");
		};
	      // clear YIELD flag
	      hwt->flags &= ~RTHREAD_ATTR_YIELDS;
	      if (hwt->slot == NULL)
		{		// whoa! out hardware's not here
		  DEBUG_PRINTF ("thread '%s': requesting bitstream load\n",
				self_name);
		  // set RECONFIG flag
		  hwt->flags |= RTHREAD_ATTR_RECONFIGURE;
		  // signal hw scheduler
		  cyg_semaphore_post (&reconos_hwsched_semaphore);
		  // now wait until our circuit has been configured to the system
		  while (hwt->slot == NULL)
		    {
		      cyg_cond_wait (&reconos_hwsched_condvar);
		    }
		  hwt->slot->state = RUNNING;
		  // lock osif mutex
		  if (!cyg_mutex_lock (&(hwt->slot->mutex)))
		    {
		      CYG_FAIL ("osif mutex lock failed, aborting thread\n");
		    };
		  // reset osif
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_reset (hwt->slot);
		  // restore context (TODO: not yet implemented!)
		  if (hwt->state_size > 0)
		    {
		      memcpy (hwt->slot->plb_base_addr + 0x4000,
			      hwt->state_buf, hwt->state_size);
#ifdef UPBFUN_RECONOS_CACHE_BURST_RAM
		      // flush cache lines corresponding to burst RAM
		      // FIXME: memory offset is hardcoded!
		      HAL_DCACHE_FLUSH ((unsigned int) (hwt->slot->
							plb_base_addr +
							0x4000),
					hwt->state_size);
#endif
		    }
		  // restore fsm state
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_resume (hwt->slot, hwt->saved_command);	// sets resume state and step according to saved command
		  // pass initialization data to hardware thread
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_init_data (hwt->slot, hwt->init_data);
		  // write local FIFO handles
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_fifo_handles (hwt->slot, hwt->fifo_read_index,
					 hwt->fifo_write_index);
		  // enable bus macros
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_busmacro (hwt->slot, 1);
		  // unblock hardware
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_unblock (hwt->slot);
		  // unlock osif mutex
		  cyg_mutex_unlock (&(hwt->slot->mutex));
		}
	      // unlock scheduling mutex
	      cyg_mutex_unlock (&reconos_hwsched_mutex);
	    }
#endif

	  if (!cyg_mutex_lock (&(hwt->slot->mutex)))
	    {
	      CYG_FAIL ("osif mutex lock failed, aborting thread\n");
	    };
	  DEBUG_PRINTF ("thread '%s': ", self_name);
	  osif_unblock (hwt->slot);
	  cyg_mutex_unlock (&(hwt->slot->mutex));
	  break;

	  //---------------------------------------------
	  // reconos_thread_delay
	  // generated from thread_delay.cmddef
	  //---------------------------------------------
	case OSIF_CMD_THREAD_DELAY:



	  // ecos_ecos () ------------------
	  {
	    cyg_thread_delay ((cyg_tick_count_t) request.data);
	  }



#ifdef UPBFUN_RECONOS_PARTIAL
	  if (request.command.flags & OSIF_FLAGS_YIELD)
	    {
	      // this was a yielding call!
	      // lock scheduling mutex
	      if (!cyg_mutex_lock (&reconos_hwsched_mutex))
		{
		  CYG_FAIL
		    ("scheduling mutex lock failed, aborting thread\n");
		};
	      // clear YIELD flag
	      hwt->flags &= ~RTHREAD_ATTR_YIELDS;
	      if (hwt->slot == NULL)
		{		// whoa! out hardware's not here
		  DEBUG_PRINTF ("thread '%s': requesting bitstream load\n",
				self_name);
		  // set RECONFIG flag
		  hwt->flags |= RTHREAD_ATTR_RECONFIGURE;
		  // signal hw scheduler
		  cyg_semaphore_post (&reconos_hwsched_semaphore);
		  // now wait until our circuit has been configured to the system
		  while (hwt->slot == NULL)
		    {
		      cyg_cond_wait (&reconos_hwsched_condvar);
		    }
		  hwt->slot->state = RUNNING;
		  // lock osif mutex
		  if (!cyg_mutex_lock (&(hwt->slot->mutex)))
		    {
		      CYG_FAIL ("osif mutex lock failed, aborting thread\n");
		    };
		  // reset osif
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_reset (hwt->slot);
		  // restore context (TODO: not yet implemented!)
		  if (hwt->state_size > 0)
		    {
		      memcpy (hwt->slot->plb_base_addr + 0x4000,
			      hwt->state_buf, hwt->state_size);
#ifdef UPBFUN_RECONOS_CACHE_BURST_RAM
		      // flush cache lines corresponding to burst RAM
		      // FIXME: memory offset is hardcoded!
		      HAL_DCACHE_FLUSH ((unsigned int) (hwt->slot->
							plb_base_addr +
							0x4000),
					hwt->state_size);
#endif
		    }
		  // restore fsm state
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_resume (hwt->slot, hwt->saved_command);	// sets resume state and step according to saved command
		  // pass initialization data to hardware thread
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_init_data (hwt->slot, hwt->init_data);
		  // write local FIFO handles
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_fifo_handles (hwt->slot, hwt->fifo_read_index,
					 hwt->fifo_write_index);
		  // enable bus macros
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_busmacro (hwt->slot, 1);
		  // unblock hardware
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_unblock (hwt->slot);
		  // unlock osif mutex
		  cyg_mutex_unlock (&(hwt->slot->mutex));
		}
	      // unlock scheduling mutex
	      cyg_mutex_unlock (&reconos_hwsched_mutex);
	    }
#endif

	  if (!cyg_mutex_lock (&(hwt->slot->mutex)))
	    {
	      CYG_FAIL ("osif mutex lock failed, aborting thread\n");
	    };
	  DEBUG_PRINTF ("thread '%s': ", self_name);
	  osif_unblock (hwt->slot);
	  cyg_mutex_unlock (&(hwt->slot->mutex));
	  break;

	  //---------------------------------------------
	  // reconos_thread_exit
	  // generated from thread_exit.cmddef
	  //---------------------------------------------
	case OSIF_CMD_THREAD_EXIT:



	  // ecos_all () ------------------
	  {

#ifdef UPBFUN_RECONOS_POSIX
	    if (hwt->flags & RTHREAD_ATTR_IS_POSIX)	// we are a POSIX thread!
	      pthread_exit ((void *) request.data);
	    else
#endif
	      {
#ifdef HWTHREAD_DEBUG
		if ((int) request.data != 0)
		  diag_printf ("Thread exited with status %d, but eCos "
			       "doesn't handle thread return values.\n",
			       (int) request.data);
#endif
		cyg_thread_exit ();
	      }

	  }



#ifdef UPBFUN_RECONOS_PARTIAL
	  if (request.command.flags & OSIF_FLAGS_YIELD)
	    {
	      // this was a yielding call!
	      // lock scheduling mutex
	      if (!cyg_mutex_lock (&reconos_hwsched_mutex))
		{
		  CYG_FAIL
		    ("scheduling mutex lock failed, aborting thread\n");
		};
	      // clear YIELD flag
	      hwt->flags &= ~RTHREAD_ATTR_YIELDS;
	      if (hwt->slot == NULL)
		{		// whoa! out hardware's not here
		  DEBUG_PRINTF ("thread '%s': requesting bitstream load\n",
				self_name);
		  // set RECONFIG flag
		  hwt->flags |= RTHREAD_ATTR_RECONFIGURE;
		  // signal hw scheduler
		  cyg_semaphore_post (&reconos_hwsched_semaphore);
		  // now wait until our circuit has been configured to the system
		  while (hwt->slot == NULL)
		    {
		      cyg_cond_wait (&reconos_hwsched_condvar);
		    }
		  hwt->slot->state = RUNNING;
		  // lock osif mutex
		  if (!cyg_mutex_lock (&(hwt->slot->mutex)))
		    {
		      CYG_FAIL ("osif mutex lock failed, aborting thread\n");
		    };
		  // reset osif
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_reset (hwt->slot);
		  // restore context (TODO: not yet implemented!)
		  if (hwt->state_size > 0)
		    {
		      memcpy (hwt->slot->plb_base_addr + 0x4000,
			      hwt->state_buf, hwt->state_size);
#ifdef UPBFUN_RECONOS_CACHE_BURST_RAM
		      // flush cache lines corresponding to burst RAM
		      // FIXME: memory offset is hardcoded!
		      HAL_DCACHE_FLUSH ((unsigned int) (hwt->slot->
							plb_base_addr +
							0x4000),
					hwt->state_size);
#endif
		    }
		  // restore fsm state
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_resume (hwt->slot, hwt->saved_command);	// sets resume state and step according to saved command
		  // pass initialization data to hardware thread
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_init_data (hwt->slot, hwt->init_data);
		  // write local FIFO handles
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_fifo_handles (hwt->slot, hwt->fifo_read_index,
					 hwt->fifo_write_index);
		  // enable bus macros
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_busmacro (hwt->slot, 1);
		  // unblock hardware
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_unblock (hwt->slot);
		  // unlock osif mutex
		  cyg_mutex_unlock (&(hwt->slot->mutex));
		}
	      // unlock scheduling mutex
	      cyg_mutex_unlock (&reconos_hwsched_mutex);
	    }
#endif

	  break;

	  //---------------------------------------------
	  // reconos_thread_yield
	  // generated from thread_yield.cmddef
	  //---------------------------------------------
	case OSIF_CMD_THREAD_YIELD:



	  // ecos_all () ------------------
	  {

#ifdef HWTHREAD_DEBUG
	    diag_printf
	      ("Thread yielded. Will resume with state 0x%02X (encoded) step %d.\n",
	       (unsigned char) request.command.
	       saved_state_enc (unsigned char) request.command.
	       saved_step_enc);
#endif

	  }



#ifdef UPBFUN_RECONOS_PARTIAL
	  if (request.command.flags & OSIF_FLAGS_YIELD)
	    {
	      // this was a yielding call!
	      // lock scheduling mutex
	      if (!cyg_mutex_lock (&reconos_hwsched_mutex))
		{
		  CYG_FAIL
		    ("scheduling mutex lock failed, aborting thread\n");
		};
	      // clear YIELD flag
	      hwt->flags &= ~RTHREAD_ATTR_YIELDS;
	      if (hwt->slot == NULL)
		{		// whoa! out hardware's not here
		  DEBUG_PRINTF ("thread '%s': requesting bitstream load\n",
				self_name);
		  // set RECONFIG flag
		  hwt->flags |= RTHREAD_ATTR_RECONFIGURE;
		  // signal hw scheduler
		  cyg_semaphore_post (&reconos_hwsched_semaphore);
		  // now wait until our circuit has been configured to the system
		  while (hwt->slot == NULL)
		    {
		      cyg_cond_wait (&reconos_hwsched_condvar);
		    }
		  hwt->slot->state = RUNNING;
		  // lock osif mutex
		  if (!cyg_mutex_lock (&(hwt->slot->mutex)))
		    {
		      CYG_FAIL ("osif mutex lock failed, aborting thread\n");
		    };
		  // reset osif
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_reset (hwt->slot);
		  // restore context (TODO: not yet implemented!)
		  if (hwt->state_size > 0)
		    {
		      memcpy (hwt->slot->plb_base_addr + 0x4000,
			      hwt->state_buf, hwt->state_size);
#ifdef UPBFUN_RECONOS_CACHE_BURST_RAM
		      // flush cache lines corresponding to burst RAM
		      // FIXME: memory offset is hardcoded!
		      HAL_DCACHE_FLUSH ((unsigned int) (hwt->slot->
							plb_base_addr +
							0x4000),
					hwt->state_size);
#endif
		    }
		  // restore fsm state
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_resume (hwt->slot, hwt->saved_command);	// sets resume state and step according to saved command
		  // pass initialization data to hardware thread
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_init_data (hwt->slot, hwt->init_data);
		  // write local FIFO handles
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_fifo_handles (hwt->slot, hwt->fifo_read_index,
					 hwt->fifo_write_index);
		  // enable bus macros
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_set_busmacro (hwt->slot, 1);
		  // unblock hardware
		  DEBUG_PRINTF ("thread '%s': ", self_name);
		  osif_unblock (hwt->slot);
		  // unlock osif mutex
		  cyg_mutex_unlock (&(hwt->slot->mutex));
		}
	      // unlock scheduling mutex
	      cyg_mutex_unlock (&reconos_hwsched_mutex);
	    }
#endif

	  if (!cyg_mutex_lock (&(hwt->slot->mutex)))
	    {
	      CYG_FAIL ("osif mutex lock failed, aborting thread\n");
	    };
	  DEBUG_PRINTF ("thread '%s': ", self_name);
	  osif_unblock (hwt->slot);
	  cyg_mutex_unlock (&(hwt->slot->mutex));
	  break;


	default:
	  CYG_FAIL
	    ("Delegate thread received unknown command from HW thread");
	}

      DEBUG_PRINTF ("<< delegate processing done for task at DCR 0x%03X\n",
		    hwt->slot->dcr_base_addr);

    }
}
