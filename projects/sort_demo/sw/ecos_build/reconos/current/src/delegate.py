#!/usr/bin/env python




##################################################
## DEPENDENCIES
import sys
import os
import os.path
try:
    import builtins as builtin
except ImportError:
    import __builtin__ as builtin
from os.path import getmtime, exists
import time
import types
from Cheetah.Version import MinCompatibleVersion as RequiredCheetahVersion
from Cheetah.Version import MinCompatibleVersionTuple as RequiredCheetahVersionTuple
from Cheetah.Template import Template
from Cheetah.DummyTransaction import *
from Cheetah.NameMapper import NotFound, valueForName, valueFromSearchList, valueFromFrameOrSearchList
from Cheetah.CacheRegion import CacheRegion
import Cheetah.Filters as Filters
import Cheetah.ErrorCatchers as ErrorCatchers

##################################################
## MODULE CONSTANTS
VFFSL=valueFromFrameOrSearchList
VFSL=valueFromSearchList
VFN=valueForName
currentTime=time.time
__CHEETAH_version__ = '2.4.2.1'
__CHEETAH_versionTuple__ = (2, 4, 2, 'final', 1)
__CHEETAH_genTime__ = 1323961995.2823229
__CHEETAH_genTimestamp__ = 'Thu Dec 15 16:13:15 2011'
__CHEETAH_src__ = '/home/rihuber/reconos/core/ecos/ecos-patched/ecos/packages/reconos/current/src/delegate.tmpl'
__CHEETAH_srcLastModified__ = 'Thu Dec 15 10:53:37 2011'
__CHEETAH_docstring__ = 'Autogenerated by Cheetah: The Python-Powered Template Engine'

if __CHEETAH_versionTuple__ < RequiredCheetahVersionTuple:
    raise AssertionError(
      'This template was compiled with Cheetah version'
      ' %s. Templates compiled before version %s must be recompiled.'%(
         __CHEETAH_version__, RequiredCheetahVersion))

##################################################
## CLASSES

class delegate(Template):

    ##################################################
    ## CHEETAH GENERATED METHODS


    def __init__(self, *args, **KWs):

        super(delegate, self).__init__(*args, **KWs)
        if not self._CHEETAH__instanceInitialized:
            cheetahKWArgs = {}
            allowedKWs = 'searchList namespaces filter filtersLib errorCatcher'.split()
            for k,v in KWs.items():
                if k in allowedKWs: cheetahKWArgs[k] = v
            self._initCheetahInstance(**cheetahKWArgs)
        

    def respond(self, trans=None):



        ## CHEETAH: main method generated for this template
        if (not trans and not self._CHEETAH__isBuffering and not callable(self.transaction)):
            trans = self.transaction # is None unless self.awake() was called
        if not trans:
            trans = DummyTransaction()
            _dummyTrans = True
        else: _dummyTrans = False
        write = trans.response().write
        SL = self._CHEETAH__searchList
        _filter = self._CHEETAH__currentFilter
        
        ########################################
        ## START - generated method body
        
        # 
        #  \file delegate.templ   cheetah template for ecos delegate thread
        # 
        #  ReconOS delegate thread code for eCos. You can generate the actual
        #  delegate.c code by issuing
        # 
        #    cheetah compile delegate.tmpl -p | python | indent > delegate.c
        # 
        #  or (recommended) by invoking
        # 
        #    make
        # 
        #  in this directory.
        # 
        #  \author     Enno Luebbers   <enno.luebbers@upb.de>
        #  \date       30.10.2008
        # 
        # ---------------------------------------------------------------------------
        #  %%%RECONOS_COPYRIGHT_BEGIN%%%
        #  
        #  This file is part of ReconOS (http://www.reconos.de).
        #  Copyright (c) 2006-2010 The ReconOS Project and contributors (see AUTHORS).
        #  All rights reserved.
        #  
        #  ReconOS is free software: you can redistribute it and/or modify it under
        #  the terms of the GNU General Public License as published by the Free
        #  Software Foundation, either version 3 of the License, or (at your option)
        #  any later version.
        #  
        #  ReconOS is distributed in the hope that it will be useful, but WITHOUT ANY
        #  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
        #  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
        #  details.
        #  
        #  You should have received a copy of the GNU General Public License along
        #  with ReconOS.  If not, see <http://www.gnu.org/licenses/>.
        #  
        #  %%%RECONOS_COPYRIGHT_END%%%
        # ---------------------------------------------------------------------------
        # 
        #  Major Changes:
        # 
        #  07.11.2008   Enno Luebbers   wrote generator delegate.tmpl for delegate.c
        #  29.01.2009   Enno Luebbers   added support for partial reconfiguration
        # 
        import sys, os
        import cmddef
        import string
        import pyparsing
        
        # command definition files to consider for the eCos delegate thread code
        files = sys.argv[1:]
        #        ['cond_broadcast.cmddef',
        #         'cond_signal.cmddef',
        #         'cond_wait.cmddef',
        #         'get_init_data.cmddef',
        #         'mbox_get.cmddef',
        #         'mbox_put.cmddef',
        #         'mq_receive.cmddef',
        #         'mq_send.cmddef',
        #         'mutex_lock.cmddef',
        #         'mutex_release.cmddef',
        #         'mutex_trylock.cmddef',
        #         'mutex_unlock.cmddef',
        #         'sem_post.cmddef',
        #         'sem_wait.cmddef',
        #         'thread_exit.cmddef']
        
        # substitutions for the CODE section of the command definiton
        # (can also be used via $subst['xxx'] within this template)
        subst = {
                'data'           : 'request.data',           # data passed from HW thread
                'datax'          : 'request.datax',          # extended data from HW thread
                'flags'          : 'request.command.flags',          # command flags
                'saved_state_enc': 'request.command.saved_state_enc',# saved state (encoded)
                'saved_step_enc' : 'request.command.saved_step_enc', # saved step
                'resources'      : 'hwt->resources',         # threads resource array
                'resource_count' : 'hwt->resource_count',    # number of resources
                'retval'         : 'retval',                 # return value variable
                'flags'          : 'hwt->flags',             # thread flags
                'plb_base_addr'  : 'hwt->slot->plb_base_addr'      # PLB base address FIXME:
                                                             #                  needed?
                }
        
        # standard header files that are always needed
        std_headers = [ ( '', '<reconos/reconos.h>' ),
                        ( '', '<stdlib.h>' ),
                        ( '', '<stdio.h>' ),
                        ( '', '<cyg/kernel/kapi.h>' ),
                        ( '', '<cyg/infra/diag.h>' ),
                        ( '', '<reconos/osif_comm.h>' ),
                        ( '', '<cyg/hal/hal_cache.h>' ) ]
        
        # read all command files
        potential_commands = cmddef.parse_files( files )
        
        # find all commands and delegates relevant to ecos, and assemble headers
        commands = []
        delegates = []
        all_headers = std_headers
        for c in potential_commands:
            for d in c.delegates:
                if d.hostOs.lower() == 'ecos':
                    if c not in commands:
                        commands.append(c)
                    if d not in delegates:
                        delegates.append(d)
                    for h in d.headers:
                        all_headers.append((d.ifdef, h))        # allow only 1 ifdef
        
        all_headers.sort()
        
        # remove duplicate header files
        assert len(all_headers) > 0
        last = all_headers[0]
        i = 1
        lasti = 1
        while i < len(all_headers):
            if all_headers[i] != last:
                all_headers[lasti] = last = all_headers[i]
                lasti += 1
            i += 1
        headers = all_headers[:lasti]
        write(u'''
''')
        # 
        #  =================== actual C code starts here ===========================
        # 
        write(u'''///
/// \\file delegate.c
///
/// ReconOS delegate thread code for eCos. NOTE: This file is generated from
/// delegate.tmpl.
///
/// DO NOT EDIT THIS FILE - it will be regenerated, overwriting your changes
/// Edit the command definitions in $RECONOS/defs or delegate.tmpl instead.
///
/// \\author     Enno Luebbers   <enno.luebbers@upb.de>
/// \\date       30.10.2008
//
//---------------------------------------------------------------------------
// %%%RECONOS_COPYRIGHT_BEGIN%%%
// 
// This file is part of ReconOS (http://www.reconos.de).
// Copyright (c) 2006-2010 The ReconOS Project and contributors (see AUTHORS).
// All rights reserved.
// 
// ReconOS is free software: you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation, either version 3 of the License, or (at your option)
// any later version.
// 
// ReconOS is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
// details.
// 
// You should have received a copy of the GNU General Public License along
// with ReconOS.  If not, see <http://www.gnu.org/licenses/>.
// 
// %%%RECONOS_COPYRIGHT_END%%%
//---------------------------------------------------------------------------
//
// Major Changes:
//
// 30.10.2008   Enno Luebbers   delegate thread code seperated from reconos.c
// 07.11.2008   Enno Luebbers   wrote generator delegate.tmpl for delegate.c
// 29.01.2009   Enno Luebbers   added support for partial reconfiguration
//

''')
        lasti = None
        for i, h in VFFSL(SL,"headers",True): # generated from line 173, col 1
            if VFFSL(SL,"i",True) and VFFSL(SL,"i",True) != VFFSL(SL,"lasti",True): # generated from line 174, col 5
                if VFFSL(SL,"lasti",True): # generated from line 175, col 9
                    write(u'''#endif
''')
                write(u'''#ifdef ''')
                _v = VFFSL(SL,"i",True) # u'$i' on line 178, col 9
                if _v is not None: write(_filter(_v, rawExpr=u'$i')) # from line 178, col 9.
                write(u'''
''')
                lasti = VFFSL(SL,"i",True)
            write(u'''#include ''')
            _v = VFFSL(SL,"h",True) # u'$h' on line 181, col 11
            if _v is not None: write(_filter(_v, rawExpr=u'$h')) # from line 181, col 11.
            write(u'''
''')
        if VFFSL(SL,"lasti",True): # generated from line 183, col 1
            write(u'''#endif
''')
        write(u'''
// CONSTANTS and MACROS ====================================================

#ifdef UPBDBG_RECONOS_DEBUG
#define DEBUG_PRINTF(format, args...) diag_printf(format , ##args)
#else
#define DEBUG_PRINTF(format, args...)
#endif

// ReconOS command encoding constants
// task2os commands
''')
        for c in VFFSL(SL,"commands",True): # generated from line 197, col 1
            write(u'''#define ''')
            _v = VFFSL(SL,"c.symbol",True) # u'$c.symbol' on line 198, col 10
            if _v is not None: write(_filter(_v, rawExpr=u'$c.symbol')) # from line 198, col 10.
            write(u'''      ''')
            _v = VFFSL(SL,"c.encoding",True) # u'$c.encoding' on line 198, col 25
            if _v is not None: write(_filter(_v, rawExpr=u'$c.encoding')) # from line 198, col 25.
            write(u'''
''')
        write(u'''

// TYPE DEFINITIONS ========================================================


// FUNCTION PROTOTYPES =====================================================

// FIXME: should this be in a header file?
#ifdef CYGPKG_KERNEL_THREADS_DESTRUCTORS
void reconos_delegate_thread_destructor(cyg_addrword_t data);   // defined in reconos.c
#endif

extern reconos_slot_t reconos_slots[NUM_OSIFS];
#ifdef UPBFUN_RECONOS_PARTIAL
cyg_mutex_t reconos_hwsched_mutex;
cyg_cond_t  reconos_hwsched_condvar;
cyg_sem_t   reconos_hwsched_semaphore;
#endif


// FUNCTIONS ===============================================================


/**** DEPRECATED ****

///
/// Find a free slot
///
/// Returns an index into the possible_slots array, or -1
/// if none of the slots are free or ready.
///

int find_free_slot(uint8 *possible_slots, uint8 num_possible_slots) {
    int i, j;

    for (i = 0; i < num_possible_slots; i++) {
        // either free or not-executing slots are okay
        j = possible_slots[i];
        if (reconos_slots[j].state == FREE ||
            reconos_slots[j].state == READY) {
           return i;
        }
    }
    return -1;
}


///
/// Prepare thread for execution
///
/// Finds suitable slot and loads bitstreams, or waits until
/// a slot becomes free
///
void prep_exec(rthread_attr_t *hwt) {
#ifdef UPBFUN_RECONOS_PARTIAL
    int i, j;
    uint8 possible_slots[NUM_OSIFS];
    reconos_bitstream_t *possible_bitstreams[NUM_OSIFS];
    uint8 num_possible_slots = 0;

    if (hwt->flags & RTHREAD_ATTR_IS_DYNAMIC) {
        // find possible slots and bitstreams
        for (i = 0; i < NUM_OSIFS; i++) {
            for (j = 0; j < hwt->circuit->num_bitstreams; j++) {
                if (hwt->circuit->bitstreams[j]->slot_num == i) {
                    possible_slots[num_possible_slots] = i;
                    possible_bitstreams[num_possible_slots++] = 
                        hwt->circuit->bitstreams[j];
                }
            }
        }
        if (hwt->circuit->num_bitstreams == 0) {
            diag_printf("no bitstreams available for circuit \'%s\'\\n",
                        hwt->circuit->name);
            cyg_thread_exit();
        }

        // find first free slot FIXME: schedule this better?
        if (!cyg_mutex_lock(&reconos_slots_mutex)) {
            CYG_FAIL("mutex lock failed, aborting thread\\n");
        } else {

            while(( i = find_free_slot(possible_slots, num_possible_slots)) < 0) { 
                cyg_cond_wait(&reconos_slots_wait);
            }

            j = possible_slots[i];
            reconos_slots[j].state = RUNNING;
            // now, j = possible_slots[i] is the slot to use
            hwt->slot = &reconos_slots[j];
            hwt->slot->thread = hwt;

            cyg_mutex_unlock(&reconos_slots_mutex);

        }

        // disable bus macros (just in case)
        osif_set_busmacro(hwt, OSIF_DATA_BUSMACRO_DISABLE);
        // load bitstream
        DEBUG_PRINTF("loading bitstream for circuit \'%s\' into slot %d...",
            hwt->circuit->name, j);
        icap_load(possible_bitstreams[i]->data, possible_bitstreams[i]->size);
        DEBUG_PRINTF("done\\n");

    } else // static thread

#endif // UPBFUN_RECONOS_PARTIAL
    {   
        if (!cyg_mutex_lock(&reconos_slots_mutex)) {
            CYG_FAIL("mutex lock failed, aborting thread\\n");
        } else {
            CYG_ASSERT(hwt->slot, "no slot associated with static thread");
            while (hwt->slot->state != READY) {
                cyg_cond_wait(&reconos_slots_wait);
            }

            hwt->slot->state = RUNNING;
            hwt->slot->thread = hwt;
            cyg_mutex_unlock(&reconos_slots_mutex);
        }
    }
}            

**********************/

//-----------------------------------------
// eCos delegate thread
//-----------------------------------------
void reconos_delegate_thread(cyg_addrword_t data)
{
\trthread_attr_t *hwt = (rthread_attr_t*)data;
\tosif_task2os_t request;
\tuint32 retval;
    char self_name[100];

#ifdef CYGPKG_KERNEL_THREADS_DESTRUCTORS
\tcyg_bool_t result = cyg_thread_add_destructor(reconos_delegate_thread_destructor, (cyg_addrword_t)hwt);
\tCYG_ASSERT (result, "Failed to attach delegate thread destructor!");
#endif

#ifdef UPBDBG_RECONOS_DEBUG
    cyg_thread_info self_info;
    strncpy( self_name, cyg_thread_get_info(cyg_thread_self(), cyg_thread_get_id(cyg_thread_self()), &self_info) ? self_info.name : "UNKNOWN", 20);

\trthread_attr_dump(hwt);
#endif

        // prepare for execution
//        prep_exec(hwt);

#ifdef UPBFUN_RECONOS_PARTIAL
        // lock scheduling mutex
        if (!cyg_mutex_lock(&reconos_hwsched_mutex)) {
            CYG_FAIL("scheduling mutex lock failed, aborting thread\\n");
        };

        // load hardware, if we\'re not static
        if (hwt->flags & RTHREAD_ATTR_IS_DYNAMIC) {
            DEBUG_PRINTF("thread \'%s\': requesting bitstream load\\n", self_name);
            // set RECONFIG flag
            hwt->flags |= RTHREAD_ATTR_RECONFIGURE;
            // signal hw scheduler
            cyg_semaphore_post( &reconos_hwsched_semaphore ); 
            // now wait until our circuit has been configured to the system
            while (hwt->slot == NULL) {
                cyg_cond_wait( &reconos_hwsched_condvar );
            }
        }
        DEBUG_PRINTF("thread \'%s\': setting slot state to RUNNING\\n", self_name);
        hwt->slot->state = RUNNING;
        cyg_mutex_unlock( &reconos_hwsched_mutex );
#endif

        CYG_ASSERT( hwt->slot != NULL, "no slot to execute thread in" );
        CYG_ASSERT( hwt == hwt->slot->thread, "thread->slot->thread links corrupt" );

        // lock osif mutex
        if (!cyg_mutex_lock(&(hwt->slot->mutex))) {
            CYG_FAIL("osif mutex lock failed, aborting thread\\n");
        };

\t// Reset HW thread
        DEBUG_PRINTF("thread \'%s\': ", self_name);
\tosif_reset(hwt->slot);

\t// wait a little FIXME: does this impede performance?
        cyg_mutex_unlock(&(hwt->slot->mutex));
\tcyg_thread_delay(1);
        if (!cyg_mutex_lock(&(hwt->slot->mutex))) {
            CYG_FAIL("osif mutex lock failed, aborting thread\\n");
        };

\t// pass initialization data to hardware thread
        DEBUG_PRINTF("thread \'%s\': ", self_name);
        osif_set_init_data(hwt->slot, hwt->init_data);

\t// write local FIFO handles
        DEBUG_PRINTF("thread \'%s\': ", self_name);
        osif_set_fifo_handles(hwt->slot, hwt->fifo_read_index, hwt->fifo_write_index);

\t// enable bus macros
        DEBUG_PRINTF("thread \'%s\': ", self_name);
        osif_set_busmacro(hwt->slot, 1);

\t// unblock hardware
        DEBUG_PRINTF("thread \'%s\': ", self_name);
        osif_unblock(hwt->slot);

        cyg_mutex_unlock(&(hwt->slot->mutex));

\tfor (;;) {
\t\t// wait for reconos delegate semaphore
\t\tcyg_semaphore_wait(&(hwt->delegate_semaphore));

\t\t// read command and data
                if (!cyg_mutex_lock(&(hwt->slot->mutex))) {
                    CYG_FAIL("osif mutex lock failed, aborting thread\\n");
                };
                DEBUG_PRINTF("thread \'%s\': ", self_name);
                osif_read_call_parameters( hwt->slot, &request );
                cyg_mutex_unlock(&(hwt->slot->mutex));

#ifdef UPBFUN_RECONOS_PARTIAL
                if (request.command.flags & OSIF_FLAGS_YIELD)  {
                    // this is a yielding call!
                    DEBUG_PRINTF("thread \'%s\': yielding call!\\n",self_name);
                    // lock scheduling mutex
                    if (!cyg_mutex_lock(&reconos_hwsched_mutex)) {
                        CYG_FAIL("scheduling mutex lock failed, aborting thread\\n");
                    };
                    // save context (TODO: not yet implemented!)
                    if( hwt->state_size > 0) {
#ifdef UPBFUN_RECONOS_CACHE_BURST_RAM
                        // invalidate cache lines corresponding to burst RAM
                        // FIXME: memory offset is hardcoded!
                        HAL_DCACHE_INVALIDATE((unsigned int)(hwt->slot->plb_base_addr + 0x4000), hwt->state_size);
#endif
                        // FIXME: memory offset is hardcoded!
                        memcpy(hwt->state_buf, hwt->slot->plb_base_addr + 0x4000, hwt->state_size);
                    }
                    // save state
                    hwt->saved_command = request.command;       // this saves state and step
                    // hwt->saved_state_enc = request.command.saved_state_enc;
                    
                    // set YIELD flag
                    hwt->flags |= RTHREAD_ATTR_YIELDS;
                    // unlock scheduling mutex
                    cyg_mutex_unlock( &reconos_hwsched_mutex );
                    // signal scheduling thread
                    cyg_semaphore_post( &reconos_hwsched_semaphore ); 
                }
#endif

\t\tswitch (request.command.code) {

''')
        for c in VFFSL(SL,"commands",True): # generated from line 455, col 1
            write(u'''                    //---------------------------------------------
                    // ''')
            _v = VFFSL(SL,"c.name",True) # u'$c.name' on line 457, col 24
            if _v is not None: write(_filter(_v, rawExpr=u'$c.name')) # from line 457, col 24.
            write(u'''
                    // generated from ''')
            _v = VFFSL(SL,"c.filename",True) # u'$c.filename' on line 458, col 39
            if _v is not None: write(_filter(_v, rawExpr=u'$c.filename')) # from line 458, col 39.
            write(u'''
                    //---------------------------------------------
                case ''')
            _v = VFFSL(SL,"c.symbol",True) # u'$c.symbol' on line 460, col 22
            if _v is not None: write(_filter(_v, rawExpr=u'$c.symbol')) # from line 460, col 22.
            write(u''':
''')
            c_delegates = VFFSL(SL,"filter",False)( lambda x: x.command == c, VFFSL(SL,"delegates",True) )
            d_restype = VFFSL(SL,"filter",False)( lambda x: x.restype, VFFSL(SL,"c_delegates",True) )
            d_no_restype = VFFSL(SL,"filter",False)( lambda x: not x.restype, VFFSL(SL,"c_delegates",True) )
            write(u'''
''')
            # ..........................................................................
            #  insert all delegate code sections which are restype dependent
            # 
            if VFFSL(SL,"d_restype",True): # generated from line 468, col 5
                write(u'''        CYG_ASSERT( ''')
                _v = VFFSL(SL,"subst",True)['data'] # u"$subst['data']" on line 469, col 21
                if _v is not None: write(_filter(_v, rawExpr=u"$subst['data']")) # from line 469, col 21.
                write(u''' < ''')
                _v = VFFSL(SL,"subst",True)['resource_count'] # u"$subst['resource_count']" on line 469, col 38
                if _v is not None: write(_filter(_v, rawExpr=u"$subst['resource_count']")) # from line 469, col 38.
                write(u''', "''')
                _v = VFFSL(SL,"c.name",True) # u'$c.name' on line 469, col 65
                if _v is not None: write(_filter(_v, rawExpr=u'$c.name')) # from line 469, col 65.
                write(u''' operation requested on non-existing resource!" );
        switch ( ''')
                _v = VFFSL(SL,"subst",True)['resources'] # u"$subst['resources']" on line 470, col 18
                if _v is not None: write(_filter(_v, rawExpr=u"$subst['resources']")) # from line 470, col 18.
                write(u''' [ ''')
                _v = VFFSL(SL,"subst",True)['data'] # u"$subst['data']" on line 470, col 40
                if _v is not None: write(_filter(_v, rawExpr=u"$subst['data']")) # from line 470, col 40.
                write(u''' ].type ) {
''')
                for d in d_restype: # generated from line 471, col 9
                    if VFFSL(SL,"d.ifdef",True): # generated from line 472, col 13
                        write(u'''    #ifdef ''')
                        _v = VFFSL(SL,"i",True) # u'$i' on line 473, col 13
                        if _v is not None: write(_filter(_v, rawExpr=u'$i')) # from line 473, col 13.
                        write(u'''
''')
                    write(u'''
            // ''')
                    _v = VFFSL(SL,"d.name",True) # u'$d.name' on line 476, col 16
                    if _v is not None: write(_filter(_v, rawExpr=u'$d.name')) # from line 476, col 16.
                    write(u''' (''')
                    _v = VFFSL(SL,"d.restype",True) # u'$d.restype' on line 476, col 25
                    if _v is not None: write(_filter(_v, rawExpr=u'$d.restype')) # from line 476, col 25.
                    write(u''') ------------------
            case ''')
                    _v = VFFSL(SL,"d.restype",True) # u'$d.restype' on line 477, col 18
                    if _v is not None: write(_filter(_v, rawExpr=u'$d.restype')) # from line 477, col 18.
                    write(u''':
                {
                    ''')
                    _v = VFN(VFN(VFFSL(SL,"string",True),"Template",False)(VFFSL(SL,"d.code",True)),"substitute",False)(VFFSL(SL,"subst",True)) # u'$string.Template($d.code).substitute($subst)' on line 479, col 21
                    if _v is not None: write(_filter(_v, rawExpr=u'$string.Template($d.code).substitute($subst)')) # from line 479, col 21.
                    write(u'''
                }
                break;

''')
                    if VFFSL(SL,"d.ifdef",True): # generated from line 483, col 13
                        write(u'''    #endif
''')
                    write(u'''        ''')
                    #  d in d_restype
                write(u'''            default: 
                CYG_FAIL( "''')
                _v = VFFSL(SL,"c.name",True) # u'$c.name' on line 488, col 28
                if _v is not None: write(_filter(_v, rawExpr=u'$c.name')) # from line 488, col 28.
                write(u''' operation requested on invalid resource type!" );
            }
    ''')
                #  d_restype
            write(u'''
''')
            # ..........................................................................
            #  insert all general code (not distinguished by restype) at the end
            # 
            if VFFSL(SL,"d_no_restype",True): # generated from line 495, col 5
                for d in VFFSL(SL,"d_no_restype",True): # generated from line 496, col 9
                    if VFFSL(SL,"d.ifdef",True): # generated from line 497, col 13
                        write(u'''    #ifdef ''')
                        _v = VFFSL(SL,"i",True) # u'$i' on line 498, col 13
                        if _v is not None: write(_filter(_v, rawExpr=u'$i')) # from line 498, col 13.
                        write(u'''
''')
                    write(u'''
                // ''')
                    _v = VFFSL(SL,"d.name",True) # u'$d.name' on line 501, col 20
                    if _v is not None: write(_filter(_v, rawExpr=u'$d.name')) # from line 501, col 20.
                    write(u''' (''')
                    _v = VFFSL(SL,"d.restype",True) # u'$d.restype' on line 501, col 29
                    if _v is not None: write(_filter(_v, rawExpr=u'$d.restype')) # from line 501, col 29.
                    write(u''') ------------------
                {
                    ''')
                    _v = VFN(VFN(VFFSL(SL,"string",True),"Template",False)(VFFSL(SL,"d.code",True)),"substitute",False)(VFFSL(SL,"subst",True)) # u'$string.Template($d.code).substitute($subst)' on line 503, col 21
                    if _v is not None: write(_filter(_v, rawExpr=u'$string.Template($d.code).substitute($subst)')) # from line 503, col 21.
                    write(u'''
                }

''')
                    if VFFSL(SL,"d.ifdef",True): # generated from line 506, col 13
                        write(u'''    #endif
''')
                    write(u'''        ''')
                    #  d in d_no_restype
                write(u'''    ''')
                #  d_no_restype
            write(u'''
''')
            # ..........................................................................
            #  make sure our hardware is back before continuing
            write(u'''
#ifdef UPBFUN_RECONOS_PARTIAL
    if (request.command.flags & OSIF_FLAGS_YIELD)  {
        // this was a yielding call!
        // lock scheduling mutex
        if (!cyg_mutex_lock(&reconos_hwsched_mutex)) {
            CYG_FAIL("scheduling mutex lock failed, aborting thread\\n");
        };
        // clear YIELD flag
        hwt->flags &= ~RTHREAD_ATTR_YIELDS;
        if (hwt->slot == NULL) {        // whoa! out hardware\'s not here
            DEBUG_PRINTF("thread \'%s\': requesting bitstream load\\n", self_name);
            // set RECONFIG flag
            hwt->flags |= RTHREAD_ATTR_RECONFIGURE;
            // signal hw scheduler
            cyg_semaphore_post( &reconos_hwsched_semaphore ); 
            // now wait until our circuit has been configured to the system
            while (hwt->slot == NULL) {
                cyg_cond_wait( &reconos_hwsched_condvar );
            }
            hwt->slot->state = RUNNING;
            // lock osif mutex
            if (!cyg_mutex_lock(&(hwt->slot->mutex))) {
                CYG_FAIL("osif mutex lock failed, aborting thread\\n");
            };
            // reset osif
            DEBUG_PRINTF("thread \'%s\': ", self_name);
            osif_reset( hwt->slot );
            // restore context (TODO: not yet implemented!)
            if( hwt->state_size > 0) {
                memcpy(hwt->slot->plb_base_addr + 0x4000, hwt->state_buf, hwt->state_size);
#ifdef UPBFUN_RECONOS_CACHE_BURST_RAM
                // flush cache lines corresponding to burst RAM
                // FIXME: memory offset is hardcoded!
                HAL_DCACHE_FLUSH((unsigned int)(hwt->slot->plb_base_addr + 0x4000), hwt->state_size);
#endif
            }
            // restore fsm state
            DEBUG_PRINTF("thread \'%s\': ", self_name);
            osif_set_resume( hwt->slot, hwt->saved_command );     // sets resume state and step according to saved command
            // pass initialization data to hardware thread
            DEBUG_PRINTF("thread \'%s\': ", self_name);
            osif_set_init_data(hwt->slot, hwt->init_data);
            // write local FIFO handles
            DEBUG_PRINTF("thread \'%s\': ", self_name);
            osif_set_fifo_handles(hwt->slot, hwt->fifo_read_index, hwt->fifo_write_index);
            // enable bus macros
            DEBUG_PRINTF("thread \'%s\': ", self_name);
            osif_set_busmacro(hwt->slot, 1);
            // unblock hardware
            DEBUG_PRINTF("thread \'%s\': ", self_name);
            osif_unblock(hwt->slot);
            // unlock osif mutex
            cyg_mutex_unlock( &(hwt->slot->mutex) );
        }
        // unlock scheduling mutex
        cyg_mutex_unlock( &reconos_hwsched_mutex );
    }
#endif            

''')
            # ..........................................................................
            #  insert write_result to HW thread, if necessary
            # 
            if VFFSL(SL,"c.options",True) and 'RETVAL' in VFFSL(SL,"c.options",True): # generated from line 577, col 5
                write(u'''        if (!cyg_mutex_lock(&(hwt->slot->mutex))) {
            CYG_FAIL("osif mutex lock failed, aborting thread\\n");
        };
        DEBUG_PRINTF("thread \'%s\': ", self_name);
        osif_write_result( hwt->slot, ''')
                _v = VFFSL(SL,"subst",True)['retval'] # u"$subst['retval']" on line 582, col 39
                if _v is not None: write(_filter(_v, rawExpr=u"$subst['retval']")) # from line 582, col 39.
                write(u''' );
        cyg_mutex_unlock(&(hwt->slot->mutex));
''')
            elif VFFSL(SL,"c.options",True) and 'BLOCKING' in VFFSL(SL,"c.options",True): # generated from line 584, col 5
                write(u'''        if (!cyg_mutex_lock(&(hwt->slot->mutex))) {
            CYG_FAIL("osif mutex lock failed, aborting thread\\n");
        };
        DEBUG_PRINTF("thread \'%s\': ", self_name);
        osif_unblock( hwt->slot );
        cyg_mutex_unlock(&(hwt->slot->mutex));
''')
            write(u'''        break;

''')
            #  commands
        write(u'''
    default:
            CYG_FAIL("Delegate thread received unknown command from HW thread");
    }

    DEBUG_PRINTF("<< delegate processing done for task at DCR 0x%03X\\n", hwt->slot->dcr_base_addr);

  }
}

''')
        
        ########################################
        ## END - generated method body
        
        return _dummyTrans and trans.response().getvalue() or ""
        
    ##################################################
    ## CHEETAH GENERATED ATTRIBUTES


    _CHEETAH__instanceInitialized = False

    _CHEETAH_version = __CHEETAH_version__

    _CHEETAH_versionTuple = __CHEETAH_versionTuple__

    _CHEETAH_genTime = __CHEETAH_genTime__

    _CHEETAH_genTimestamp = __CHEETAH_genTimestamp__

    _CHEETAH_src = __CHEETAH_src__

    _CHEETAH_srcLastModified = __CHEETAH_srcLastModified__

    _mainCheetahMethod_for_delegate= 'respond'

## END CLASS DEFINITION

if not hasattr(delegate, '_initCheetahAttributes'):
    templateAPIClass = getattr(delegate, '_CHEETAH_templateClass', Template)
    templateAPIClass._addCheetahPlumbingCodeToClass(delegate)


# CHEETAH was developed by Tavis Rudd and Mike Orr
# with code, advice and input from many other volunteers.
# For more information visit http://www.CheetahTemplate.org/

##################################################
## if run from command line:
if __name__ == '__main__':
    from Cheetah.TemplateCmdLineIface import CmdLineIface
    CmdLineIface(templateObj=delegate()).run()


